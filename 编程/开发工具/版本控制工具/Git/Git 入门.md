[TOC]

### 前言

**什么是 Git？**

git 是世界上最先进的分布式版本库控制系统。

特点： 高端，大气，上档次。

**为什么要使用 Git？**

个人开发改进迭代，团队内部协作

**版本控制工具应该具有的功能：**

- 协同修改

  - 多人并行不悖的修改服务器端的同一个文件。即多个人同时修改，一个人经过修改提交后，并不会对其它提交修改进行覆盖，可并行存在。

- 数据备份

  - 不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态。 

- 版本管理

  - 在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空 间，提高运行效率。这方面 SVN 采用的是增量式管理的方式，而 Git 采取了文 件系统快照的方式 。

- 权限控制 

  - 对团队中参与开发的人员进行权限控制。 

  - 对团队外开发者贡献的代码进行审核——Git 独有 

- 历史记录：

  - 查看修改人、修改时间、修改内容、日志信息。 
  - 将本地文件恢复到某一个历史状态。 

- 分支管理

  -  允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。 

### 第一章 Git 简介

##### 1.1 Git 的诞生

Linus 在 1991 年创建了开源的 Linux。Linux 虽然是 liuns 创建的，但 Liunx 的壮大是靠全世界热心的志愿者参与。这么多人为 Linux 写代码，那么 Liunx 的代码时如何实现管理的呢。

而这些代码早期是靠 Liuns 本人实现手工合并代码。

到了 2002 之后，代码库已经十分庞大，很难通过手工的方式实现代码的管理。

2002 年 (被授权免费使用)使用商业软件 BitKeeper

2005 年 BitKeeper 的使用权被收回(因试图破解)。Linus 自己用 C 语言开发了一个分布式版本控制系统。

2008 年 GitHub 上线 

注：SVN/CVS（免费） 集中式版本控制系统：速度慢，而且必须联网才能使用。有商用的版本控制系统虽然必 SVN/CVS 好用，但是那是付费的。

##### 1.2 集中式 VS 分布式

集中式和分布式版本控制有什么区别？

**集中式版本控制系统**：版本库是集中存放在中央服务器的。而干活的时候，用的都是自己的电脑，必须要先从中央服务器取得最新的版本，然后工作，工作之后，再把自己工作后的内容推送给中央服务器。

集中式版本控制系统的最大毛病就是必须联网才能工作。

> 本人电脑上获取的时最新那个状态的文件，为什么历史版本、过去的状态信息。也就说一旦中央服务器宕机之后，那么我们过去的历史状态等信息将荡然无存

**分布式版本控制系统**：

首先，分布式排版控制系统根本就没有 “中央服务器”。每个人的电脑上都有一个完整的版本库，这样工作的时候就不需要联网了。

既然每个人的电脑都有一个完整的版本库，那么多人工作如何协作？

例如，你在自己电脑上修改了文件 A，而你的同事也在电脑上修改了文件 A。这时只需要把各自的修改推送给对方就可以了。

安全性：于集中式排版系统相比，分布式版本控制系统的安全性就高很多了。因为每个人的电脑都哟一个完整的版本库，因此，某个人的电脑坏掉了不要仅，随便从其他人哪里复制一个版本库就可以了。而集中式排版系统，如果中央服务器出现了问题，那么所有人都无法工作了。

在实际上使用分布式版本控制系统的时候，很少在两个人的电脑之间推送修改。因为两个人又可能不在同一个局域网中，两台电脑相互访问不了。因此，分布式版本控制系统中通常也有一台充当 “中央服务器” 的电脑，这个服务器的作用：方便推送大家之间的修改，没有它大家一样可以干活，只是修改不方便而已。

**其它版本库控制系统**：

*免费的*：

- **CVS**：

  最早的开源且免费的集中式版本控制系统。

  由于自身设计的问题，会导致提交文件不完整，版本库莫名其妙损坏的情况

- **SVN**：

  免费、开源，且修改了一些 CVS 中一些稳定性的问题，是目前使用最多的集中式版本控制库控制系统

收费的：

- **IBM 的 ClearCase** 

  特点：安装比 Windows 大，运行比蜗牛慢。

- **微软的 VSS**

  集成在 Visual Studio,设计反人类。

  其他的版本控制系统：BitKeeper、类似Git 的 Mercurial、Bazaar

##### 1.3 版本控制简介

思想：工程设计领域中使用版本控制 管理工程蓝图的设计。

##### 1.4 Git 的优势：

- 大部分操作在本地完成，不需要联网
- 完整性保证
- 尽可能添加数据而不是删除或修改数据
- 分支操作非常快流畅
- 与 Linux 命令全面兼容

##### 1.5  Git 和代码托管中心

代码扩管中心的任务：维护远程库

- 局域网环境下：
  - GitLab 服务器
- 外网环境下：
  - GitHub
  - 码云

##### 1.6  本地库和远程库

- 团队内部写作
- 跨团队写作

### 第二章 安装 Git及设置签名

##### 2.1 安装 Git

- Linux 上安装 Git:

首先输入:  `git` 看看有没有安装，还会告诉你如何安装。

- 在 Mac OS 中安装 Git:

两种安装方式：

1. 安装 Homebrew,然后通过 homebrew 安装 Git,具体安装方法参考 homebrew 的文档：<https://brew.sh/>

- 在 Windows 上安装 Git

具体安装步骤查看文档 Git&Github.pdf

地址：<https://git-for-windows.github.io

windwos 的 <https://gitforwindows.org/> (这两个站点再国内下载不了,除非用 VPN)

Git 国内下载点:<https://github.com/waylau/git-for-win>

Git 官网地址：<https://git-scm.com/>

在开始菜单中找到 Git ——》 Git Bash 打开后出现一个类似于命令行窗口的东西，就说明安装成功了。

##### 2.2设置签名

安装完成后，还需要最后一步设置，在命令行输入：

```git
git config --global user.name "你的昵称"
git config --global user.email "你的 Email 地址"
```

因为 Git 是分布式版本控制系统，所以每个电脑都必须自曝家门。

> 这里设置的签名和登录远程库(代码扩管中心)的账号、密码没有任何关系。

注意：使用了 Git config 命令的 --global 参数，表示你这台机器上的所有仓库都会使用该配置。也可以对某个仓库自定不同的用户名和 Email 地址。

命令：

- 项目级别/仓库级别：仅在当前本地库范围内有效

  ```git
  git config user.name 用户名 
  git config user.email 邮箱地址
  ```

  信息保存位置: `./.git/.config`

- 系统用户级别：登录当前操作系统的用户范围

  ```git
  git config --global user.name 用户名
  git config --global user.email 邮箱地址
  ```

  信息保存位置：`~/.git/.gitconfig`

- 级别优先级：

  - 就近原则：项目级别优先于系统用户级别，两者都有时采用项目级别的签名
  - 如果只有系统级别的签名，就以系统用户级别签名为准
  - 不允许二者都没有

## 本地库操作

### 第三章 创建版本库

什么是版本库？

版本库又名仓库，英文名 responsitory 

```
mkdir 文件夹的名字 //创建文件夹
cd 文件夹的名字 //进入这个文件夹
pwd //显示当前文件所在的路径
git init //可以把当前所在位置变为 Git 可以管理的仓库
ll  文件名称 // 显示隐藏文件的名称
```

注： Git Bash 不同于 windows 命令行，如果像要调转到其他盘符，要用 `CD 盘符名称：`。windows 则为： 直接输入盘符，例如：`D:`。

**没事千万不要手动修改和删除.git 目录中的文件，**负责容易把 Git 版本库给破坏了。

如果看不到 .git 目录，那是因为 .git 目录默认是隐藏的，使用 `ls -ah` 命令就可以看到。

##### 把文件添加到版本库

所有的版本控制系统，只能跟踪文本的改动。比如 TXT 文件、网页、所有程序代码等等。版本控制系统可以告诉你每次的改动。例如在第 5 行添加了一个单词，或删除了一个标点符号。

而图片、视频哪些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变量，总股本不过把二进制文件每次改动串联起来，例如：只知道图片从 100KB 改成了 120KB

注：Mcirosoft 的 word 格式也是二进制，因此版本控制系统是没法跟踪 word 文件的改动的。建议使用 UTF-8 编码(Unicode 也可以)。

**不要使用 windows 自带的记事本编辑任何文本文件，否则程序有可能导致编译错误。**(建议使用 notepad++ 代替)

原因：因为 MS 开发记事本的团队，在保存文件编码为 UTF-8 格式的文档时，为每个文件的开头添加了一个类似于 0xefbbbf 的字符。因此编译程序的时候可能会出现一些稀奇古怪的问题。

**第一步**：git add 告诉 Git，把文件添加到仓库。

`git add readme.md //将 readme 文件添加仓库`

"没有消息就是好消息。"

**第二步**：git commit 告诉 Git，把文件提交到仓库。

`git commit -m "wrote a readme file"`

-m 后面的内容是本次提交的说明。最好是有意义的。这样就能历史记录中方便的找到改动记录。

```
git commit -m "wrote a readme file"
[master (root-commit) 12c6d50] wrote a readme file
 1 file changed, 3 insertions(+)
 create mode 100644 readme.md
```

git commit 执行成功后，会告诉你 1 文件被改动，这个文件有 3 行内容

为什么 Git 添加文件需要 add commit 两步?

commit 可以一次提交很多文件，可以多次 add 不同的文件。

```
git add file1.txt
git add file2.txt
git commit -m "add 3 files"
```

### 第四章 时光穿梭机

**基本操作：**

- `git status` 查看工作区、暂存区状态
- `git add fileName` 将工作区的“新建/修改”添加暂存区
- `git commit -m "describe（描述）" [filename]` 将暂存区中的内容或暂存区中指定的"修改/新建"添加到版本库

**查看历史记录：**

- `git log` 最完整形式

  多屏显示控制方式：

  - `空格` 向下翻页

  - `b` 向上翻页
  - `q` 退出

  显示：哈希值、提交人昵称、邮箱、提交时间、描述、

- `git log --pretty=oneline`

  以表格形式显示：

  显示哈希值、和描述信息

- `git log --oneline`

  相比上一个命令，哈希值只显示前 n 位

- `git reflog`

  相比上一个命令，多了移动到第 * 个版本，需要移动 * 步 例如：`HEAD@{N}`// N 就是移动该版本所需要的步数

**版本前进后退总结：**

- 基于索引值操作[推荐]: `git reset --hard 哈希索引值`

- 使用 ^ 符号: 只能后退

  ` git reset --hard HEAD^//表示后退一个版本`或简写为 `git reset --hard HEAD^n`

  注：一个^表示后退一步，n 个表示后退 n 步

- 总用 ~ 符号: 只能后退

  `git reset --hard HEAD~n`

  表示后退 n 步

rset 命令的三个参数：

- --soft: 仅在本地库移动 HEAD指针
- --mixed: 在本地库移动 HEAD 指针，并重置暂存区
- --hard： 在本地库移动 HEAD 指针，重置暂存区和工作区

**删除文件找回：**

- 前提：删除前，文件存在时的状态提交到了本地库

- 操作：`git reset --hard 指针索引值`
  - 删除操作已经提交到本地库：指针位置：历史记录
  - 删除操作尚未提交到本地库：指针位置：当前记录或 HEAD

放弃工作区中的内容：

- `git checkout 文件名`
- `git restore 文件名`

**比较操作**

- 工作区与缓存区中的内容作比较： `git diff [filename]`

  diff 就是单词 difference 的缩写

- 工作区与版本库中的内容作比较：`git diff HEAD apple.txt` //甚至和历史记录中的版本作比较

- 不加文件名，多个文件进行比较

```git
On branch master//在 master 分支
#Changes not staged for commit://缓存区中没有内容提交
#(use "git add <file>..." to update what will be committed)//通过 git add 命令来更新已经改变的内容
#(use "git checkout -- <file>..." to discard changes in working directory)//通过 git checkout 命令来放弃工作区中的内容
#        modified:   readme.md //已经修改的文件
no changes added to commit (use "git add" and/or "git commit -a")//没有内容提供交

//版本没有提交到仓库
# Changes to be committed: //改变将被提教
# (use "git reset HEAD <file>..." to unstage) //通过该命令来放弃该版本
#
# modified: readme.txt //已经被修改过的文件，也就是与版本库中内容不符

//提交后
nothing to commit (working directory clean)//没有内容要提交
```
提交修改和提交新文件两步是一样的。

当我们没有需要提交的修改，Git 会告诉我们工作目录是干净的 working directory clean

##### 4.1 版本回退

查看修改历史记录：`git log`

git log 命令显示从最近到最远的提交日志。

如果嫌输出的信息太多，看的人眼花缭乱，可以在 git log 命令的后面添加 `--pretty=oneline`

显示如下：

```
1a61114345a90e8eae19e3487f97662ab7db65c0 (HEAD -> master) append GPL
c668eaa87722f8cd3a9446bd8b73d92d6a3d427b add distributed
12c6d5001281579313a57bfaacd6a7c1516e5f49 wrote a readme file
```

前面的一串 16 进制数字就是 commit 的 id

在 Git 中，HEAD 表示当前版本。

HEAD^ 就是上一个版本，HEAD^^ 就是上上一个版本。再往上 100 个版本 100 个 ^ 数起来有些麻烦。我们可以用 HEAD~100 表示。

**git reset 进行版本切换**：

例如：`git reset --hard HEAD^ //就是回退到上一个版本。`

**cat 查看当前版本指定文件的内容**：

语法标记：`cat 文件名称.文件类型`

例如：`cat readme.md`

想要恢复到之前的版本，怎么办。

第一种：如果命令行窗口没有关闭，往上找，找到那个版本 commit id,然后用 git reset 就可以会回到那个指定的版本。

注：id 没必要写全，只要前3位就可以了（Git 会自动去寻找），不能只写前一两位。

第二种：如果命令行窗口关闭

通过 git reflog 查看命令历史。

##### 4.2 工作区和暂存区

**工作区** Working Directory 

就是在电脑里能看到的目录。

**暂存区** 暂时存储文件

**版本库** Reponsitory

工作区有一个隐藏目录 .git,这个不算工作区，而是 Git 的版本库。

Git 版本库中存了很多东西，其中最重要的组成：

-  stage(或 index)的暂存区
-  Git 自动为我们创建的第一个分支 master
-  以及指向 master 的一个指针叫 Head

<img src="../MarkdownImages/gitmemory.png">

第一步：用 git add 添加文件，就是把文件修改添加到暂存区

第二步：用 git commit 提交更改，就是把暂存区中的所有内容提交当当前分支。

如果我们工作区中的文件从来没有被添加过，那么那么的它的状态为 Untracked 未知

```
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        license.md

no changes added to commit (use "git add" and/or "git commit -a")
```

##### 4.3 管理修改

为什么 Git 比其他版本控制系统更优秀？

因为 Git 跟踪管理的是修改，而非文件。

当我们修改一个文件之后，要先将其添加到缓冲区，然后提交包版本库中。

##### 4.4 撤销修改

不常用：如果没有添加到缓存区就在源文件中修改。

- 使用 `git checkout -- 文件名称.文件类型`：
  - 文件修改后，还没有被放到暂存区，现在撤销修改就回到和版本库一摸一样的状态
  - 文件已经加载到暂存区，又作了修改，现在撤销修改就回到添加到到暂存区后的状态。

- 撤销暂存区的修改，回退到工作区：`git reset HEAD  文件类型.文件名称`

如果提交到版本库，参考版本回退。（前提没有提交到远程版本库）

##### 4.5 删除文件

一般情况下直接在文件管理器中文件删除(或 cmd 中 rd 删除)或者用 rm 命令删除。

当删除之后，Git 知道你删除了文件，工作区和版本库就不一致了，git status 命令会告诉你哪些文件被删除了。

可以有两个选择：

一、在版本库中删除该文件

用 git rm 并且用 git commit 将文件提交。

例如：

```
rm readme.md //从工作区删除该文件
git rm readme.md //从版本库中删除该文件
git commit -m "提示内容"//提交
```

二、误删、把误删的文件恢复到最新版本。

`git checkout -- test.md`//git checkout 就是将版本库里的版本，替换工作区的版本。

##### 4.6 让 GitBisect 帮助你

###### Bisect

就是利用二分法查找来查找某一分支到底是那一次

###### 自动化

##### 4.7 分支管理

**1. 什么是分支？**

在版本控制过程中，使用多条线同时推进多个任务。

**2. 分支的好处**

- 同时并行推进多个功能开发，提高开发效率 
- 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任 何影响。失败的分支删除重新开始即可。 

**3. 分支操作**

-  创建分支： `git branch 分支名`

- 查看分支:  `git branch -v `

- 切换分支: `git checkout 分支名`

- 合并分支： 

  - 第一步：切换到接受修改的分支（被合并，增加新内容）上 git checkout [被合并分支名] 
  -  第二步：执行 merge 命令 `git merge [有新内容分支名] `

- 解决冲突

  - 冲突的表现

    ![](branch.png)

  - 冲突的解决

    - 第一步：编辑文件，删除特殊符号 
    -  第二步：把文件修改到满意的程度，保存退出 
    -  第三步：git add [文件名] 
    - 第四步：git commit -m "日志信息" 
    -  注意：此时 commit 一定不能带具体文件名 

### 第五章 Git 原理

##### 5.1 Hash 算法

 哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下 几个共同点：

​	 ① 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 (16 字节数据)

​	②哈希算法确定，输入数据确定，输出数据能够保证不变

​	 ③哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 	

​	④哈希算法不可逆 

Git 底层采用的是 SHA-1  算法

哈希算法可以被用来验证文件

SHA1，MD5，CRC32

##### 5.2 Git 保存版本的机制

5.2.1 集中式版本控制工具的文件管理机制

 以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本 文件和每个文件随时间逐步累积的差异。 

5.2.2 Git 的文件管理机制

Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前 的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改， Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的 工作方式可以称之为快照流。 

文件管理机制细节

##### 5.3 Git 分支管理机制

## 远程库操作

### 第六章 远程仓库

> 由于 GitHub 在国内速度很慢，因此使用码云来代替 GitHub 本质上差不了多少

具体创建仓库注册等操作详见百度或 Git&GitHub.pdf

**6.1 为远程仓库地址别名**

- `git remote -v` 显示当前仓库所有远程地址及别名
- `git remote add [别名] [远程地址]` 为远程地址起别名

**6.2 推送：** `git push [别名] [分支名]`

**6.3 克隆**： `git clone 远程库地址`

效果:

-  完成的远程仓库下载到本地
-  创建 origin 远程地址名
- 初始化本地库 

```
echo "# Studynote" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:rsrmXJ/Studynote.git
git push -u origin main
```



