# 正则表达式

使用*单个字符串*来描述，匹配一系列符合某个句法规则的字符串。

使用工具：RegexBuddy

**1. 为什么需要正则表达式?**

文本的复杂处理

**2. 正则表达式的优势和用途？**

- 强大而灵活的文本处理
- 大部分编程语言、数据库、文本编辑器和开发软件都可以使用正则表达式

**3. 正则表达式**

- 描述的是一个规则，通过一定的规则可以匹配一类字符串

- 学习正则表达式很大程度上就是**学习正则表达式的语法规则**

**4. 正则表达式的基本语法：**

- 普通字符

  字母、数字、汉字、下划线以及没有特殊意义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配字符串时，匹配与之相同的字符。

- 简单的转义字符

  `\n 换行 \t 制表 \\ \^ \$ \. \( \) \? \+ \* \| \{ \}字符本身` 

- 标准字符集合

  - 能够与“多种字符"匹配的表达式

  - 注意区分大小写，大写是取反的意思

    | \d   | 任意一个数字 0~9                                             |
    | ---- | ------------------------------------------------------------ |
    | \w   | 任意一个字母或数字或下划线                                   |
    | \s   | 包括空格、制表符、换行符等空白字符的任意一个                 |
    | .    | 小数点可以匹配匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用`[\s\S]` |

- 自定义字符集合

  - `[]` 能够匹配方括号中任意一个字符

  - 例如：

    | [abc@5]    | 匹配 "a"或"b"或"c",或"@"或"5"        |
    | ---------- | ------------------------------------ |
    | [^abc]     | 匹配 "a","b","c"之外的任意一个字符   |
    | [a-f]      | 匹配 “a~f” 之间的任意一个字符        |
    | \[^A-F0-3] | 匹配 `“A~F”,"0~3"`之外的任意一个字符 |

    - 正则表达式的特符号，被包含到中括号中，则失去意义，除了 `-^`之外
    - 标准字符合集，除小数点外，如果被包含于中括号，则自定义字符集合将包含该集合，比如：
      - [\d.\\-+]将匹配：数字、小数点、+、-

- 量词 （Quantifier）

  | {n}   | 表达式重复 n 次                      |
  | ----- | ------------------------------------ |
  | {m,n} | 表达式至少重复 m 次，最多重复 n 次   |
  | {m,}  | 表达式重复至少 m 次                  |
  | ？    | 匹配表达式 0 次或者 1 次相当于 {0,1} |
  | +     | 表达式至少出现 1 次，相当于 {1,}     |
  | *     | 表达式不出现或出现任意次 {0,}        |

  - 贪婪模式（匹配字符个数越多越好，默认）
  - 非贪婪模式，匹配的字符个数越少越好，修饰匹配次数的特殊符号后，再加上一个 "?"

- 字符边界

  - 本组标记匹配的不是字符而是位置，符合某种条件的位置

    | ^    | 与字符串开始的地方匹配 |
    | ---- | ---------------------- |
    | $    | 与字符串结束的位置匹配 |
    | \b   | 匹配一个单词边界       |

  - \b 匹配这样要给位置：前面的字符或后面的字符不全是 \w 例如：`single\b` 就是 single 后面不能是数字、字母或下划线，前面无所谓

- 模式选择

  - IGNORECASE 忽略大小写模

    - 匹配时忽略大小写

      注：正则表达式区分大小写(默认)

  - SINGLELINE 模式

    - 整个文本看作一个字符串，只有开头，一个结尾
    - 使小数点 "." 可以匹配包含换行符 （\n）在内的任意字符

  - MULTILINE 多行模式

    - 每一行都是一个字符串，都有开头和结尾
    - 在制定了 MULTILINE 之后。如果需要仅匹配字符串开始和结束位置，可以使用\A 和 \Z。文本最开始和最末尾，忽略每一行字符串的开始和结尾。

- 选择符和分组

  | 表达式         | 作用                                                         |
  | -------------- | ------------------------------------------------------------ |
  | \| 分支结构    | 左右量变表达式之间 "或" 关系，匹配左边或右边<br />例如：`表达式1 | 表达式2 ` 既匹配表达式 1， 也匹配表达式 2 |
  | () 捕获组      | 1.在被修饰匹配次数的时候，括号中的表达式作为整体被修饰 <br />2.取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br />3. 每一对括号都会分配一个编号，使用 () 的捕获根据左括号顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获式由整个正则表达式模式匹配的文本<br />注：分组捕获的内容会被存到内存中 |
  | (?:Expressio） | 一些表达式中不得不使用 (),但又不需要保存()中子表达式匹配的内容，这时可以用非捕获组来抵消用 () 带来的副作用 |

  

- 反向引用 (\nnn)

  - 每一对 () 会分配一个编号，使用 () 的捕获根据**左括号和顺序**从 1 开始自动编号

  - 通过反向引用，可以对分组已捕获的字符串进行引用

    `([a-z]{2})\1 ` 那么它就可以匹配 abab 结构的字符串。

- 预搜索(零宽断言)

  - 只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度、
  - 这个位置应该符合某个条件。判断当前位置的前或后字符，是否符合指定的条件的条件，但不匹配前后的字符。是对位置的匹配。
  - 正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的结果中，那么就认为这个子表达式是占有字符的；如果表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是**零宽度**的，占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果而言的。

  | (?=exp)  | 断言自身出现的位置的后面能匹配表达式 exp |
  | :------: | ---------------------------------------- |
  | (?<=exp) | 断言自身出现的位置的前后能匹配表达式exp  |
  | (?!exp)  | 断言此位置的后面不能匹配表达式exp        |
  | (?<!exp) | 断言此位置的前面不饿能匹配表达式exp      |

  ![Snipaste_2020-04-03_11-12-06](Snipaste_2020-04-03_11-12-06.png)