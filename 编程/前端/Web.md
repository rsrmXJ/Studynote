# Web 

Web 页面由三部分组成：内容(结构) HTML、表现 CSS、行为 JavaScript

## 第一部分 HTML

### 1. 基本概念：

- 浏览器：实现用户和浏览器之间的交互、浏览器和服务器之间数据的交换。

  - 浏览器内核：浏览器所采用的的渲染引擎，渲染引擎决定了如何显示示网页的内容，以及页面格式

    |   浏览器名称    |     内核名称     |
    | :-------------: | :--------------: |
    |       IE        |     Trident      |
    | Mozilla firefox |      Gecko       |
    |  Google Chrome  | Webkit/blink内核 |
    |     Sarfari     |    Webkit内核    |
    |      Opera      |    Presto内核    |

- 服务器：高配置的电脑

  特点：

  - 高可靠性
  - 可扩展性强

- HTTP (hypertext transport protocol)：超文传输协议，规范了通过网络发送和接受HTML页面的规范。

  HTTP 将用户浏览网页的一次行为过程定义为客户端（终端用户）与服务器端（网站）的交互。

- HTML（hypertext markup language）：超文本标记语言

- URL（Uniform Resource Locator）：全球资源定位器。就是网址

- URI (Uniform Resource Identifier)： 统一资源标识符。网络中的每一个数据文件都有全球唯一的地址

> - 协议：规范、约束一类事物
>
> - 纯文本文件：只包含字符的文件。表现：能用记事本打开且正常显示的文件

**2.** URL 各个部分的组成：`协议类型://域名:端口号/我们所请求资源的地址`

**3.** 超文本传输协议 HTTP:

主要分为：

- 请求报文格式：请求行+请求头+空格+请求体 request header:

- 响应报文格式：响应行+响应头+响应体 response header:

浏览网页的一个过程：在地址栏中输入 URL 回车，然后先查询本地地址表中是否有该域名对应的的 IP地址：

- 如果有，则加上端口号（默认为 80）发送请求报文
- 如果没有，则先到 DNS 服务器中查询域名对应的 IP 地址

**4.** 字符集：字符（文字）的集合。

保存文件时编码还必须与文档中字符指定的集合相一致（\<meta charset="UTF-8"\>），否则会出现乱码的现象。（在保存文件时将编码格式改为相应的字符集）。  

> 在企业开发中我们应该用GBK（GB2312）还是UTF-8呢？
>
> - 如果开发的网站仅包含中文，那么推荐使用 GB2312,因为它的体积较小，访问速度更快，
> - 如果开发的网站中除了中文以外，还包含了一些其他一些国家的语言，那么推荐使用UTF-8。速度相比GBK（GB2312）稍慢一点。（因为GBK是使用两个字节保存一个字，而UTF-8则使用3个字节保存一个字）
> - 懒人推荐不管什么时候都使用 UTF-8

### 2. HTML 基本常识：

1. HTML 文件的扩展名是 `.html` 或 `.htm`

2. HTML 是一种标记语言，标记语言只是一套标记(并不是编程语言)，HTML 文档用标记来描述文档。

3. HTML 唯一的作用就是描述文本语义（就是告诉浏览器这是个标题、还是段落……）。这些用来描述其他文本的语义的文本，我们将其称之为**标签**。标签在浏览中是不会被显示出来的。

4. 超文本就是页面内可以包含图片、视频、音频甚至音乐、程序等非文字元素(但注意这些是和html 分离的，只是嵌入在 html 中，否则 HTML文档就不是纯文本文档了)。

5. HTML 标签分为 html 元素和空元素

   - html 元素：｀开始标签＋内容＋结束标签｀。例如：`<h1>What are you 弄啥哩</h1>`

   - 空元素：空元素在开始标签中进行关闭（以开始标签的结束而结束）。例如 : `<img src="">`

     注意：空元素没有内容

注意：

- 在 HTML 中有一些标签和属性不是用来描述语义的（例如 hr br），一般不要用这样的标签属性（主要通过 CSS 来完成属性）。

- 虽然我们利用标签描述文本之后，这些文本在浏览器中显示出来的样式会发生改变，但要记住：HTML 的作用只有一个就是给文本添加语义，而不是用来修改文本样式的。 

- HTML 文档 = 网页

### 3. HTML 文档的网页结构

- \<html\>标签作用就是告诉浏览器这是一个网页；

  - 一个网页中的所有标签必须在 html 的起始和闭合标签之间
- 我们通过 html 之间的文本描述网页内容
- 在HTML文档中主要由**头部**（由\<head\>标签定义）和**主体**（由\<body\>标签定义）两大部分组成。
- <head\>,\<\head\> ：提供关于网页（网站）的相关信息。  
  - 网站的标题和logo。
  - 添加SEO信息（指定网站的关键字/网站的描述信息）
  - 外挂一些 js 文件和 css 文件。
  - 添加一些浏览器适配的相关内容。、
  - <tittle\>：指定网页的标题。用户收藏网页时的名称。tittle必须写在head标签的里面。
- \<body\>：提供网页的内容（给用户查看的内容，文字/图片/视频等）


注意：

1. 一般情况下，写在 head 标签中的内容是不会显示给用户查看的（除了 title 和 logo）。
2. 写给用户查看的内容不要写到 body 标签以外

```html
<!DOCTYPE html> <!--文档声明-->
<html lang="en"><!--指明本网页支持的语言，zh-CN 汉语，en 英语-->
    <head>
    <meta charset="UTF-8"> <!--指明字符集-->
    <title>What are you 弄啥哩</title><!--网页标题-->
</head>
<body>
<!--Web 页面的主体内容-->
</body>
</html>
```

### 4.其它内容

什么是单标签、双标签以及元素呢？

- 单标签：没有闭合（结束）标签的标签。

- 双标签：一个开始标签和一个闭合标签。

- 元素：起始标签+内容+闭合标签

标签存在两种关系：

- 并列关系：（兄弟/平级）-
- 嵌套关系：（父子/上下级关系）

标签拥有自己的属性：

- 基本属性：bgcolor="red"; 可以修改简单的样式效果
- 事件属性：onclick="alert{"Hello"]}" 设置事件响应后的代码。

### 5. DTD 文档声明

- 作用：告诉浏览器这个网页是用那个版本的HTML文档规范来写。之后浏览器根据版本开始处理

- 为什么要有 DTD 文档声明？

  由于 html 有多个版本，每个版本之间又存在一定的差异，所以为了让浏览器能够正确的处理，我们需要在 HTML 文本的第一行告诉浏览器采用那个版本的规范。浏览器知道我们采用了那个浏览器的版本规范，它就能够正确的处理 html 文档。

- 如果不写DTD文档声明后有什么后果？

	1. 不写DTD文档声明是不合法的。因为这样做不符合W3C的规范。
	2. 在浏览器中主要有两种解析模式：标准模式和混杂模式。如果不写文档声明将开启混杂模式导致格式混乱。

- DTD 文档声明的格式：每个版本的HTML都有不同的文档文档声明。

**注意：**

1. 浏览器判断当前 HTML 文件是采用那个版本，不完全依赖通过 DTD 文档声明，还有自己的一套机制进行判断。也就是说没有 DTD 文档声明网页也能正常运行，但是 W3C 规定第一行必须写上 DTD 文档声明，所以为了遵守规定，HTML 文件第一行必须写上 DTD 文档声明。
2. 在DTD文档声明必须写到第一行。
3. DTD文档声明只是一个声明，并不是一个标签，因此没有结束标签。
4. 不区分大小写

> HTML、XHTML和HTML5的区别？
> - HTML语法非常松散容错性强。
> - XHTML要求更为严格，它要求标签必须小写，必须严格闭合，标签中的属性值必须用引号引起等
> - HTML5是 HTML 的下一个版本所以除了非常宽松容错性强以外，还增加许多新特性。
> 
> 常见的前端开发工具：
> - notepad++ / editplus: 提示功能差
> - Dreamwaver: 更偏向设计
> - Sublime: 轻量级，自带功能不全，但是插件十分丰富。
> - webstorm 重量级、自带功能全面

### 6. webstorm 中的快捷键：

- 新建文件：Ctrl+alt+insert   

- 快速复制光标所在的哪一行： CTRL+D

- 快速剪切光标所在的哪一行：CTRL+X

- `SHift+Alt + 按住鼠标左键拖拽:`让光标在 webstorm 中多行出现

- `Ctrl+Alt+T`：包裹选中的内容

- `Ctrl +/`：注释选中的内容

- 快速移动选中的代码上下移动。

  - 向上移动：CTRL+SHIFT+方向键上。 向下移动：CTRL+SHIFT+方向键向下

  - 快速合并：CTRL+"-" ;快速多个合并;CTRL+SHIFT+"-"

  - 快速打开：CTRL+"+" ;快速多个打开：CTRL+SHIFRT+"+"

  - 快速新建一行：`Shift+Enter`

### 7. 标签

#### 1. h 标题标签、font 字体标签

**h 标题标签**

给文字添加标题语义，共有六个，从 h1 至 h6 。独占一行。h1 最大，h6 最小。

**注意：**

- 在企业开发中我们要慎重使用 h 系列标签，尤其是 h1 标签。
- 浏览器会自动地在标题的前后添加空行。默认情况下浏览器会自动在块级元素前后添加一个空行。
- 在企业开发中一个页面只能出现一个 h1 表签（与 SEO 有关，搜索引擎使用标题来为网页编制索引）。

属性：

- align 对齐属性：left right center 

**font 字体标签**

- color 属性修改颜色
- face 属性修改字体
- size 属性修改大小

#### 2. 常见标签 p hr br

- p 给文本添加段落语义。单独占行。

- hr 添加水平线、分割线。

  用于分隔内容。使用水平线 (\<hr\> 标签) 来分隔文章中的小节是一个办法（但并不是唯一的办法）

- br 换行。

> 为什么在企业开发中很少使用 br 标签？
>
>  由于 \<br\> 标签的语义是不另起一个段落换行，而在企业开发中一般都是要另起一个段落换行，所以在企业开发中很少使用 \<br\> 标签。
>
> - br 标签：段落还没有完。
>- p 标签：如果需另起段落则需要使用 p 标签。

#### 3. 注释

注释：提高可读性，使代码更容易被别人理解。 格式 ：\<!\-- 注释内容\--\>

#### 8. img 标签

语法标记：`<img src="url" weight height tittle alt>`

- img就是英文 images 的缩写。img 的标签的作用就是告诉浏览器我们需要显示一张图片
- src 就是英文 source 的缩写，就是告诉浏览器需要显示的图片存放的位置和资源名称。
- tittle 用于鼠标悬停的图片上方时需要弹出描述框显示的内容。
- alt 其实是英文 alternate 的缩写，就是告诉浏览器需要显示的图片不见了显示什么内容。（图片的替代文字）
- border 设置图像的边框大小

注意:  图片尺寸

1. 如果手动设置图片的宽高会导致图片变形，不想让图片变形可以**指定宽或高**。
2. 不会独占一行。
3. 在没有设置宽高的情况下，将会按照图片默认的大小
4. 仅仅在当前工程下或网络的图片才可以显示

> 标签的属性
>
> - 属性总是以属性名称、值对的形式出现
> - 格式：属性名称="值"
>
> **注意：**属性值应该是指被包括在引号内。使用双引号、单引号都可以。在个别情况下，比如属性值本善就含有双引号，那必须使用单引号，反之亦然。

#### 9. 路径

**相对路径**

1\. 相对路径都是从 HTML 文件所在的位置开始查找。是相对于当前 HTML 文件

	同级：需要插入的文件和 HTML 文件在同一个文件夹中。

   - 格式：src="Qrecode.jpg\";

   - 含义：在当前 html 文件所在文件夹找到 \"Qrecode.jpg\" 。

  下级：需要插入的文件在 HTML 文件夹中的一个文件夹中（最常用）。

   - 格式：src=\"文件夹名称/文件名称\" eg:src=\"images/Qrecode.jpg\";

   - 含义：在当前 html 文件所在文件夹找到 images 文件夹，人后再再images文件夹中找到\"Qrecode.jpg\"文件。
	
	上级：需要插入的文件和 HTML 所在文件夹在的上一级文件夹中。

   - 格式：\<src=\"../images/asfdf.png\"\>

   含义：在当前.html文件所在文件夹的上一级文件中找到images文件夹，然后再找到\"asfdf.png\"文件。

2\. 从盘符开始查找文件

**注意：**

- 路径中不能出现中文否则会出现未知问题。
- 如果通过相对路径来指定,不能跨盘符
- 在企业开发中要使用/反斜杠，不要使用\\正斜杠，因为开发的程序会部署到其他服务器的系统上，而其服务器系统使用都是"/"。如果使用\\正斜杠会出现难以预料的错误。

> 相对路径：
>
> - .                当前文件所在的目录
> - ..              当前文件所在的上一级目录
> - 文件名    当前文件所在目录的文件，相当于 ./文件名，./ 可以省略
> - 文件夹名\文件名 当前目录下，指定的子目录下指定的文件 
>
> 绝对路径：
>
> 正确：https://ip:port/工程名/资源路径
>
> 错误：盘符:/目录/文件名
>
> 资源路径=目录+文件名

#### 8. a 超链接标签

-  用于控制页面与页面（包括他本身，例如从顶部跳转到底部）之间的跳转。
- 语法标记：\<a href=\"需要跳转的目标页面的位置\"\>需要给用户查看的内容(图片、文字…)</a\>

**注意：**

1. a 标签不仅可以让文字点击后进行跳转，还可以让图片/视频点击之后进行跳转。
2. a 标签必须要有href属性，否则浏览器不知道要跳转到什么地方。
3. 如果 href 属性指定的是一个 URL 地址，那么地址前添加http:// 或 https://
4. href 属性不仅可以指定一个URL地址，也可以指定本地的地址。

**a 标签属性**

target ：设置如何跳转到目标页面的指定位置

- _self 不新建页面跳转（默认）
- _blank 新建页面跳转

tittle 用来显示鼠标悬停在上面时的信息。

#### 10. base 标签

Base 标签就是专门制定当前网页所有超链接 a 标签如何打开。

注意：

1. base标签必须写在head标签的开始标签与结束标签之间。

2. 如果既在base标签指定，又在 a 标签指定，那么浏览器会按照a执行。

#### 11. 假链接、锚点

假链接：指向当前界面的一种，点击之后，页面不会跳转的链接，因为在开发前期页面都还没有做出来，链接执行称为问题，等到后期其他页面做出来后，我们再将假链接替换为真链接。

- \# 点击之后会自动到网页顶部。例如：`<a href="#">回到网页顶部</a>` 
- href 属性值为空也是回到网页顶部
- `JavaScript:` 点击之后不会自动到网页顶部。例如：`<a href="JavaScript:">这是一个假标签</a>`

**锚点**

- 作用：就是跳转到当前页面或其他页面的指定位置。
- 可以点击的，并且还会跳转到指定位置，所以使用 a 标签。
- 必须告诉告诉 a 标签要跳转的位置，因此就需要一个独一无二的标识符。在 HTML 可以为每一个标签设置一个独一无二的id。

**创建锚点**

1. 给目标标签添加一个 id 属性， 然后指定一个唯一的值。
2. 告诉 a 标签需要跳转的 id 
3. 语法格式：\"\<a href = "#idValue" \>\</a\>\"可以跳转到当前页面的指定位置，也可以跳转到指定页面的指定位置\"\<a href = "targetHtmlName\#idValue" \>\</a\>\"。

注意：使用 a 标签没有过渡动画。如果需要有过渡动画，则不能使用 a 标签

#### 12. 列表

列表：给数据添加列表语义，告诉浏览器这一堆数据是一个整体。

列表分类：

- 无序列表（Unordered List） 没有先后之分
- 有序列表（Ordered List） 有先后之分
- 定义列表（Definition List）

 **无序列表** 

- 给一堆数据添加列表语义，数据没有先后之分。

- 应用场景;新闻 商品 导航条

注意：

1. ul 标签和 li 标签是一个整体，因此，不会单独出现而是结合在一起使用。

2. ul 标签是给一堆数据添加列表语义的，而不是添加小圆点的。

3. 由于 ul 和 li 标签是一个组合，所以 ul 中不推荐包含其他标签，也就是 ul 标签中只可以放 li 标签 但li标签可放其他标签又来丰富内容。

```html
<ul>
    <li>新闻</li>
    <li>时事</li>
    <li>购物</li>
</ul>
```

WebStorm 中快捷生成 ul 列表：`Ul>li*3`生成一对ul标签，在这一对 ul 标签中生成三对 li 标签

list item列表条目 \<li\>

**属性：**

type：disc 实心圆，circle 空心圆，square 实心正方形 ，none 没有

**有序列表**

给一堆数据添加列表语义，数据有先后之分。

格式：

```html
<ol>
    <li></li>
    <li></li>
    <li></li>
</ol>
```

注意：略（和无序差不多一致）

**属性**：

- type:  i  A a 1 

- reversed 规定列表顺序为降序 。目前只有chrome和Sarfari 支持 语法：\<ol reversed\>  

- start 属性 规定有序列表的起始值 （chrome 只有数字支持 start 属性）

**定义列表**

```html
<dl>
    <dt\></dt>	 dt是definition tittle的缩写 用来描述标题
    <dd\></dd> dd是definition description用来描述标题对应的描述
</dl>
​```
```

- 通过 dt 定义列表中的标题，用 dd 描述对标题对应的描述。

- 应用：网站尾部的描述信息 做图文混排。

注意：

1. 一个 dt 可以没有对应的dd,也可以有多个对应的 dd。推荐一个 dt 对应一个 dd.

2. dt/dd和li标签一样，可以在其中添加其他标签来丰富内容

#### 13. 表格

格式：

```html
<table>
    <tr>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>
```

- table：给这堆数据添加表格语义，告诉浏览器这是个表格。
- tr: 表格中的一行
- td: 一行表格中的一个单元格

注意：空的单元格的边框是不会被显示出来的，为了避免这种情况的发生，需要在空的单元格中添加一个空格占位符，这样边框就可以显示出来

**属性：**

table

- border 边框的宽度
- weight 宽度
- height 高度
- align 设置表格相对于页面的对齐方式
- cellspacing 规定*单元格之间*的间距
- cellpadding 规定单元边沿与其内容之间的间距
- summary  表格的摘要为盲人设计在页面中通常不会显示

tr、th、td

- align 设置单元格文本的对齐方式

注意：

1. 边框属性，这个属性代表了边框的宽度，在默认的情况下属性值为"0"，看不到框。
2. 表格的宽度和高度默认根据内容的尺寸来决定，也可以通过 table 标签和 td 标签的weight 和 height 来决定；如果给td标签设置width和height属性会改变当前单元格的大小，但不会改变整个表格的大小。

table 表格中的元素

| caption | 表格标题<br />标签必须紧随 table 标签之后。一个表格只能定义一个标题。通常这个标题会被居中于表格之上。 |
| ------- | ------------------------------------------------------------ |
| th      | 表格表头(列的标题)                                           |
| thread  | 表格的页眉                                                   |

- col 表格列的属性

- colgroup 表格列的组

```html
<html>
<head>
<style type="text/css">
thead {color:green}
tbody {color:blue;height:50px}
tfoot {color:red}
</style>
</head>
<body>

<table border="1">
  <thead>
    <tr>
      <th>Month</th>
      <th>Savings</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>January</td>
      <td>$100</td>
    </tr>
    <tr>
      <td>February</td>
      <td>$80</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>Sum</td>
      <td>$180</td>
    </tr>
  </tfoot>
</table>

</body>
</html>
```

**表格对齐**

- 水平方向 align: table tr td th 

- 垂直方向 valign：tr td

**注意：**给 tr 设置了位置属性，给 td 也设置了位置属性，那浏览器会按照 td 设置的属性来执行。也就说表格中单元的对齐方式，取绝离它最近的那个属性的设置

1. 水平对齐，table 标签的水平对齐，对的是整个表格；只有 tr td th 对齐的才是内容

**外边距和内边距：**

外边距 cellspacing：单元格和单元格之间的距离。默认 2 px.

内边据 cellpadding：单元格边框和文字之间的距离。默认 1 px.

注释：外边距和内边据只有 table 标签能够使用。

**细线表格**

1. 给 table 设置 bgcolor 为黑色。

2. 给 tr 设置 bgcolor 为白色。

3. 给 table 标签设置 cellspacing 为 1px

**单元格合并**

1. 水平方向单元格和并。colspan 指定其中一个单元格当作多个单元格使用。

单元格只能向下或向后合并。

2. 垂直方向单元格合并：rowspan 用法同colspan

#### 14. 表单标签 

1. 表单就是用来搜集用户信息的集合
2. 表单元素有特殊的外观和默认的功能。
3. 表单元素格式：

```html
<form action="">
    <!--表单元素-->
</form>
```

**常见表单元素有：input**

input 标签type属性的取值决定input这个标签的外观和功能。

| type 属性取值                                                | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| text                                                         | 明文输入                                                     |
| password                                                     | 暗文输入                                                     |
| radio                                                        | 单选按钮                                                     |
| checkbox                                                     | 复选按钮                                                     |
| submit                                                       | 提交按钮：将表单中填写好的数据提交到远程服务器。             |
| button                                                       | 可点击的按钮<br />图片按钮：src 属性值为 图片的路径或 url    |
| reset                                                        | 重置填写的数据，通过 value 属性指定按钮标题                  |
| file                                                         | 文件上传域                                                   |
| hidden                                                       | 隐藏域<br/>当我们需要发送某些信息，而这些信息无需用户参与，不需要用户看到，就可以使用隐藏域 |
|                                                              |                                                              |
| **注释：**表单本身并不可见。文本字段输入框的默认宽度是 20 个字符 | 默认值:value="\*\*\*"                                        |

**单选框**

格式：`<input type="radio"\>`

**注释：**默认情况下不会互斥，必须给每一个单选框设置一个 name 属性，name 属性必须设置相同的值，如果想要单选框默认选中某个单选框可以给 input 加一个 checked 属性：`checked="checked"`

 **普通按钮：**

\<input type="button"\>

- 可以通过value属性指定按钮的标题(就是按钮上显示的内容)
- 作用：配合js完成一些操作。

***提交到服务器的必备条件:***

1. 需要在 form 中设置 action 的属性通过这个属性**指定提交到服务器的地址**。
2. 把需要提交到服务器的表单项（单选、复选、下拉列表中的 option）设置一个 name 属性。
3. 表单项要有 value 值。
4. 表单项必须要在 form 标签中

**action 属性**

action 属性定义在提交表单时执行的动作。向服务器提交表单的通常做法是使用提交按钮。

如果省略 action 属性，则 action 会被设置为当前界面。

**method 属性**

method 属性规定在提交表单时所使用的 http 方法（get或post）

get 特点：明文 

- 浏览器地址栏中的地址：action属性值[?参数]

  参数格式：表单项name值=表单项value值&表单项name值=表单项value值…

- 不安全

- 有数据长度的限制

post 特点：密文

- 浏览器地址中只有 action 属性值
- 相对于 get 安全
- 理论上没有数据长度的限制



1\. 何时使用get（默认方法）？

- 如果表单提交是被动的（比如搜索引起查询），没有敏感信息。当使用 get 时，表单数据在页面地址栏时可见的。- 
-  get 最适合少量数据的提交。浏览器会设定容量限制。

2\. 何时使用 post？

- 如果表单正在更新数据，或者包含敏感信息（例如：密码）
- post 的安全性更佳，因为在页面地址栏中被提交的数据是不可见的。

**下拉列表 select 标签**

```html
<select name="" id="">
    <option value=""></option>
    <option value=""></option>
    <option value=""></option>
</select>
```

- select 下拉列表框
- option 下拉列表框中的内容

通过 select="selected" 设置默认选中。

**多行文本输入框 textarea 标签**

- 属性：
  - cols 一行可以显示字符的个数
  - rows 显示的行数
- 起始标签和结束标签的内容的就是多行文本输入的默认值

**文字聚焦**

也就是点击文字之后，直接让光标定位到对应的输入框。默认情况下文字和输入框没有关联，我们可以让文字和输入框绑定来实现。

方式一：使用 label 标签

```java
<label for="male">文字</label>
  <input type="radio" name="sex" id="male" />
```

**datalist**

给输入框绑定待选项，来定义 input 可能的值。

格式：

```html
<datalist id="">
    <option value=""></option>
    <option value=""></option>
    <option value=""></option>
    <option value=""></option>
</datalist>

例子：
<input type="text" list="cars" />
<datalist id="cars">
	<option value="BMW">
	<option value="Ford">
	<option value="Volvo">
</datalist>
```

注意：

- datalist 标签一般和 input 标签配合使用
- input 元素的 list 属性必须引用 datalist 元素的 id 属性值

 input 的list 属性

**表单格式化**

可以用表格对其进行格式化，例如：

```html
<table>
    <tr>
        <td>昵称</td>
        <td><input type="text" name="name"></td>
    </tr>
    <tr>
        <td>密码</td>
        <td><input type="password" name="passwd"></td>
    </tr>
    <tr>
        <td>性别:</td>
        <td><input type="radio" name="sex" value="boy"> boy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="radio" name="sex" value="girl">girl</td>
    </tr>
</table>
```

表单中的其它标签

- fielddest 定义表格边框线
- legend 定义表单标题

限制非法输入：略。请查看文档

注意：输入限制并非万无一失。JavaScript 提供了很多方法来增加非法输入。如需安全地限制输入，则接受者（服务器）必须同时对限制进行检查。

**html5 表单标签**

- email
- url
- number
- date
- color

例子：`<input type="date">`

#### 16.  ifarme 标签

在页面上开普一个小区域显示一个的单独的页面

iframe 标签和 a 标签配合使用的步骤：

1. 在 iframe  标签中使用 name 属性定义一个值
2. 在 a 标签的 target 属性设置 iframe 标签的 name 属性的属性值

属性 src 指定页面。

#### 17. marquee 走马灯标签

该标签已被废弃

- 格式：\<marquee\>内容\<marquee\>
- direction 设置滚动方向
- scrollamount 设置滚动速度
- behavior 设置滚动类型
  - side  滚到边界后从头 开始滚动
  - Alternate 来回滚

#### 18. video 标签

- src
- Controls：控制显示进度条等
- Poster： 没有播放视频时的占位图片

#### 19. 引用

**短引用 q**

表现：浏览器会为 q 元素中的文本添加双引号。

**长引用 blockquote** 

浏览器会对 blockquote 中的内容，进行换行和缩进

**其它的标签**

**abbr** 用于定义缩写或首字母缩写域。

格式：`<abbr tittle="缩写词语完整表示"\>缩写词语</abbr\>`

> 对缩写进行标记能够为浏览器、翻译系统及搜索引擎提供有用的信息 

**dfn** 

**address**

- 定义作者或拥有者的联系信息

**cite** 

- 定义著作的标题
- 浏览器会以斜体显示 cite 元素中的文本

#### 20. video audio 标签

属性:

- src：要播放音频的地址
- aotoplay: 准备就绪自动播放
- controls: 向用户显示控件
- loop：循环(用于做广告)
- muted: 静音模式
- prepload：预加载，会与 aoutplay 互斥，如果设置了aoutplay 那么 preload 会失效
- poster 播放之前的占位图片
- weight：宽度、height 高度

**格式：**

````html
第一种：1 个地址
<video src=""></video>
第二种：多个地址，备用
<video src="">
    <source src="">
    <source src="">
    <source src="">
</video>
````

#### 21. 被废弃的标签

HTML标签只有一个作用就是添加语义，在早期有一部分标签没有语义而是用来修改样式的，所以这一部分被淘汰了。

- 例子：\<br\> \<hr\> \<font\> \<b\>(bold)\<u\>（下划线）\<i\>（斜体）\<S\>（删除的文字）

- 现在虽然也可以使用但是是作为钩子使用的。

- Strong 代替 b  ins代替u   em代替i  del 代替s

  很多标签都可以用来改变文本的外观，并为文本关联其隐藏的含义。总地来说，这些标签可以分成两类：基于内容的样式（content-based style）和物理样式（physical style）。

#### 22. dfn 标签



#### 23. 详情概要

```html
<details>
    <summary>概要信息</summary>
详情信息
</details>
```

用 summary 标签描述概要信息，用 details 描述详情信息

表现：默认情况下折叠显示， 看详细信息需要点击

#### 22. 字符实体

1\. 在HTML中对空格/Tab/回车不敏感，（不管空再多的连续空格行只当一个空格字符）

2\. 在HTML中的某些字符是有特殊含义不能被显示出来，如果想要显示出来必须要通过字符实体。

- `<`　`&lt;` less than
- `>`    `&gt;` great than
- 空格 `&nbsp;`
- 版权符号 &copy;  `@copy;`

### 8.注意：

1\.  标签不能交叉嵌套 。错误演示：`<div><span>你好啊<\div><\span>`

2\. 标签必须正确的关闭

3\. 属性必须要有值，值必须用引号括起来

4\. 注释不能嵌套

注：其它标签略，查文档百度吧

## CSS

### 1. 什么是 CSS？

Cascading stylesheet 层叠样式表，是用于控制网页样式，并许将网页样式信息与网页内容分离的一种标记型语言。

浏览器会根据 CSS 对 Web 页面进行格式化(修改样式。)

**体验 CSS**

*通过标签修改样式的缺点：*

1\. 需要记忆哪些标签有哪些属性, 如果该标签没有这个属性, 那么设置了也没有效果

2\. 当需求变更时我们需要修改大量的代码才能满足现有的需求
3\. HTML只有一个作用就是用来添加语义，所以在开发中修改样式都是交给 CSS 来做

*通过 CSS 来修改样式的好处：*

1\. 不用记忆哪些属性属于哪个标签

2\. 当需求变更时我们不需要修改大量的代码就可以满足需求

3\. 在前端开发中CSS只有一个作用, 就是用来修改样式

#### CSS 语法规则：

格式：

```css
选择器{
    属性:值;
    属性:值;
    …
    属性:值;
}
```

- 选择器：浏览器根据“选择器”决定受 CSS 样式影响的 HTML 元素
- 属性：属性，即要改变的样式名(如：bgcolor)。每个属性都有一个值。属性和值之间用冒号隔开。这些属性被花括号包围，这样就组成了一个完整的样式声明。
- 如果定义多个样式声明，则需要用在样式声明尾部添加分号，将每个声明隔开。
- 一般每行只描述一个属性

**注意点：**

1\. style 标签必须写在 head 标签的开始标签和结束标签之间(也就是必须和 title 标签是兄弟关系)

2\. style 标签中的 type 属性其实可以不用写, 默认就是 type="text/css"

3\. 设置样式时必须按照固定的格式来设置 key:value;
其中分号不能省略, 分号大多数情况下也不能省略、

> CSS 怎么学?
> CSS 的学习一共分为两大部分, 一个是 CSS 的属性, 另一个是 CSS 选择器. 也就是说着两部分学完 CSS 就没有别的东西了
>
> style 标签为什么要写在 head 标签中？

### 2. 如何使用样式表？

三种插入样式表的方法：

- 外部样式表

  当样式表被应用很多页面的时候，外部样式表时最合适选择，修改样式表，可以该变整个网站的外观。

  例子：`<link rel="stylesheet" type="text/css" href="mystyle.css">`

- 内部样式表

  当单个文件需要特别样式时，就需要使用内部样式表，可以在 head 标签中通过 **style 标签**来定义内部样式表

  缺点：只能在同一个页面中复用。

- 内联样式表

  当特殊的样式需要应用到个别元素时，就需要使用内联样式表。

  通过 style 属性设置 `key:value;key:value` 来修改延时

  例如：

  ```
  <p style="color: red; margin-left: 20px">
  This is a paragrap。</p>
  ```

缺点：

- 样式多了，代码量大
- 可读性差
- 复用性差

### 3. CSS 的三大特性：

- 继承性
- 层叠性
- 优先级

**继承**

1\. 给父元素设置属性，子元素也可以使用

2\. 并不是所有的属性都可以继承，只有以 color/font-/text-/line开头的都可以继承

3\. 在 CSS 中不仅仅儿子可以使用，只要是后代都可以使用

4\. 继承性中的特殊性

1. a 标签的文字颜色和下划线是不能继承的
2. h 标签的文字大小是不能继承的

应用场景：

一般用于设置网页上的共性信息，例如网站文字的颜色，和字体大小。

**层叠性**

- 层叠性就是CSS处理冲突的一种能力
- 层叠性只有在多个选择器选中"同一个标签", 然后又设置了"相同的属性", 才会发生层叠性。

**优先级**

当多个选择器选中同一个标签, 并且给同一个标签设置相同的属性时, 如何层叠就由优先级来确定。

*优先级判断的三种方式*

1\. 间接选中(继承)

如果是间接选中, 那么就是谁离目标标签比较近就听谁的

2\. 直接选中

- 同类型选择器

  如果都是直接选中, 并且都是同类型的选择器, 那么就是谁写在后面就听谁的

- 不同类型选择器

  如果都是直接选中, 并且不是相同类型的选择器, 那么就会按照选择器的优先级来层叠
  
  id>类>标签>通配符>继承>浏览器默认

### 4. CSS 选择器

#### 1\. 标签名选择器

根据指定的标签名称, 在当前界面中找到所有该名称的标签, 然后设置属性

格式：

```
标签名称{
    属性:值;
}
//举例：
p{
	color: red;
}
```

注意点：

1\. 标签选择器选中的是当前界面中所有的标签, 而不能单独选中某一个标签

2\. 标签选择器无论标签藏得多深都能选中

3\. 只要是HTML中的标签就可以作为标签选择器(h/a/img/ul/ol/dl/input....)

#### 2\. id 选择器

根据指定的id名称找到对应的标签, 然后设置属性

格式：

```css
#id名称{
    属性:值;
}
例如：
#identity1{
    color: red;
}
```

注意点：

1\. 在  HTML 中每个标签都可以设置 id。

2\. 在同一个页面面中id的名称是不可以重复的

3\. 在编写 id 选择器时一定要在 id 名称前面加上#

4\. id 标识符命名规则：

1. 只能由字母、数字、下划线、组成
2. 不能以数字开头
3. id 名称不能是 html 标签的名称

5\. 在企业开发中一般情况下如果仅仅是为了设置样式, 我们不会使用id ,因为在前端开发中id是留给js使用的

#### 3\. class 类选择器

根据指定的类名称找到对应的标签, 然后设置属性

格式：

```css
.类名{
    属性:值;
}
//一个标签绑定一个类名
<p class="pp">迟到毁一生</p>
//一个标签绑定多个类名
.para1{
    font-size: 100px;
}
.para2{
    font-style: italic;
}
<p class="para1 para2">我是段落</p>
```

注意：

1\. HTML 中的每个标签都可以设置属性

2\. 在同一个界面中 class 名称是可以重复的

3\. 在编写class选择器时一定要在class名称前面加上`.`

4\. 类名的命名规则和 id 名的命名规则一样

5\. 类名就是专门用来给CSS设置样式的

6\. 在HTML中每个标签可以同时绑定多个类名

**id 选择器和 class 选择器**

区别：

- id名称 相当于人的身份证不可以重复

  class名称 相当于人的名称可以重复

- 一个 HTML 标签只能绑定一个 id 名称
  一个 HTML 标签可以绑定多个 class 名称

- id 选择器是以 `#` 开头
  class 选择器是以 `.` 开头

到底是使用 id 选择器还是使用 class 选择器？

id 一般情况下是给 js 使用的, 所以除非特殊情况, 否则不要使用 id 去设置样式

> 在开发中要注重冗余代码的抽取, 可以将一些公共的代码抽取到一个类选择器中, 然后让标签和这个类选择器绑定即可

#### 4\. 后代选择器

找到指定标签的所有特定的后代标签, 设置属性

格式：

```css
标签名称1 标签名称2{
    属性:值;
}
例子：
div p{ }
```

先找到所有名称叫做"标签名称1"的标签, 然后再在这个标签下面去查找所有名称叫做"标签名称2"的标签, 然后在设置属性

注意：

1\. 后代选择器必须用空格隔开

2\. 后代不仅仅是儿子, 也包括孙子/重孙子, 只要最终是放到指定标签中的都是后代

3\. 后代选择器不仅仅可以使用标签名称, 还可以使用其它选择器

4\. 后代选择器可以通过空格一直延续下去

#### 5\. 子元素选择器

找到指定标签中所有特定的直接子元素, 然后设置属性

格式：

```css
标签名称1>标签名称2{
    属性:值;
}
```

先找到所有名称叫做"标签名称1"的标签, 然后在这个标签中查找所有直接子元素名称叫做"标签名称2"的元素

注意点：

1\. 子元素选择器只会查找儿子, 不会查找其他被嵌套的标签

2\. 子元素选择器之间需要用>符号连接, 并且不能有空格

3\. 元素选择器不仅仅可以使用标签名称, 还可以使用其它选择器

4\. 子元素选择器可以通过>符号一直延续下去

**后代选择器和子元素选择器**

不同点

1\.  后代选择器使用空格作为连接符号；子元素选择器使用>作为连接符号

2\. 后代选择器会选中指定标签中, 所有的特定后代标签, 也就是会选中儿子/孙子..., 只要是被放到指定标签中的特定标签都会被选中；子元素选择器只会选中指定标签中, 所有的特定的直接标签, 也就是只会选中特定的儿子标签

共同点：

1\. 后代选择器和子元素选择器都可以使用标签名称/id名称/class名称来作为选择器

2\. 后代选择器和子元素选择器都可以通过各自的连接符号一直延续下去
`选择器1>选择器2>选择器3>选择器4{}`

**后代选择器和子元素选择器如何选择？**

如果想选中指定标签中的所有特定的标签, 那么就使用后代选择器。如果只想选中指定标签中的所有特定儿子标签, 那么就使用子元素选择器。

#### 6\.  交集选择器

所有选择器选中的标签中, 共有的那部分标签设置属性

格式 ：

```CSS
选择器1选择器2{
    属性: 值;
}
```

注意点：

1\. 选择器和选择器之间没有任何的连接符号

2\. 选择器可以使用标签名称/id名称/class名称

3\. 交集选择器仅仅作为了解, 企业开发中用的并不多

#### 7\. 并集选择器

所有选择器选中的标签设置属性

格式:

```css
选择器1,选择器2{
    属性:值;
}
```

注意点：

1\. 并集选择器必须使用 `,`来连接

2\. 选择器可以使用标签名称/id名称/class名称

#### 8\. 兄弟选择器

**相邻兄弟选择器**

给指定选择器后面紧跟的那个选择器选中的标签，设置属性

格式：

```css
选择器1+选择器2{
    属性:值;
}
```

注意点：

1\. 相邻兄弟选择器必须通过+连接

2\. 相邻兄弟选择器只能选中紧跟其后的那个标签, 不能选中被隔开的标签

**通用兄弟选择器**

给指定选择器后面的，所有选择器选中的所有标签设置属性

格式：

```css
选择器1~选择器2{
    属性:值;
}
```

注意点：

1\. 通用兄弟选择器必须用~连接

2\. 通用兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签, 无论有没有被隔开都可以选中

#### 9\. 序选择器

1\. 同级别中的第几个？

- :first-child 选中同级别中的第一个标签
- :last-child 选中同级别中的最后一个标签
- :nth-child(n) 选中同级别中的第n个标签
- :nth-last-child(n) 选中同级别中的倒数第n个标签
- :only-child 选中父元素中唯一的标签、

注：它是根据同级别中的第 n 个是否符号条件来判断的。也就是有有多少级就判断多少次。

2\. 同类型的第几个？

- :first-of-type 选中同级别中同类型的第一个标签
- :last-of-type  选中同级别中同类型的最后一个标签
- :nth-of-type(n) 选中同级别中同类型的第n个标签
- :nth-last-of-type(n)  选中同级别中同类型的倒数第n个标签
- :only-of-type 选中父元素中唯一类型的某个标签
- :nth-child(odd) 选中同级别中的所有奇数
- :nth-child(even) 选中同级别中的所有偶数
- :nth-child(xn+y)
  x和y是用户自定义的, 而n是一个计数器, 从0开始递增

#### 10\. 属性选择器

据指定的属性名称找到对应的标签, 然后设置属性

格式一：

attribute属性

```css
[attribute
根据指定的属性名称找到对应的标签, 然后设置属性

例子：
 p[id]{
 	color: red;
 }
 //找到所含有 id 属性的 p 标签然后设置 color 为 red
```

格式二:

```
[attribute=value]
找到有指定属性, 并且属性的取值等于 value 的标签, 然后设置属性
最常见的应用场景, 就是用于区分input属性
 p[class=cc]{
 	color: blue;
 }
```

补充：

1\. 属性的取值是以什么开头的

```css
[attribute|=value] CSS2
[attribute^=value] CSS3
```

两者之间的区别:

- CSS2 中的只能找到 value 开头,并且 value 是被-和其它内容隔开的
- CSS3 中的只要是以 value 开头的都可以找到, 无论有没有被-隔开

2\. 属性的取值是以什么结尾的
[attribute$=value] CSS3

3\. 属性的取值是否包含某个特定的值得

```css
[attribute~=value] CSS2
[attribute*=value] CSS3
```

两者之间的区别:

- CSS2中的只能找到独立的单词, 也就是包含value,并且value是被空格隔开的
- CSS3中的只要包含value就可以找到

#### 11\. 通配符选择器

 给当前界面上所有的标签设置属性

格式：

```css
*{
    属性:值;
}
```

注意点:
由于通配符选择器是设置界面上所有的标签的属性, 所以在设置之前会遍历所有的标签, 如果当前界面上的标签比较多, 那么性能就会比较差, 所以在企业开发中一般不会使用通配符选择器

#### 12. 伪元素选择器

1\. 什么是伪元素选择器?

伪元素选择器作用就是给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素

2\. 格式:

```html
标签名称::before{
    属性名称:值;
}
给指定标签的内容前面添加一个子元素

标签名称::after{
    属性名称:值;
}
给指定标签的内容后面添加一个子元素

例如：
        div::after{
            /*指定添加的子元素中存储的内容*/
            content: "么么哒";
            /*指定添加的子元素的宽度和高度*/
            width: 50px;
            /*height: 50px;*/
            /*内容是可以超出标签的范围的, 所以高度为0依然可以看见内容*/
            height:0;
            background-color: pink;
            /*指定添加的子元素的显示模式*/
            display: block;
            /*隐藏添加的子元素*/
            visibility: hidden;
        }
```

### 3. 文字属性 和 !important 提高权重

#### 1. 文字属性

1\. 规定文字样式的属性
格式：`font-style: italic;`

**取值：**

- normal ： 正常的， 默认就是正常的

- italic :  倾斜的

**快捷键**：
- fs font-style: italic;

- fsn font-style: normal;

2\.规定文字粗细的属性

格式：` font-weight: bold;`

**取值:**

- bold 加粗
- bolder  比加粗还要粗
- lighter 细线， 默认就是细线
- 数字取值：100-900之间整百的数字

快捷键

- fw font-weight:;
- fwb font-weight: bold;
- fwbr  font-weight: bolder;

3\.规定文字大小的属性

格式：`font-size: 30px;`

单位：px（像素 pixel）

**注意点：**

通过 font-size 设置大小一定要带单位， 也就是一定要写 px

**快捷键**

- fz font-size:;
- fz30 font-size: 30px;

4\.规定文字字体的属性
格式：`font-family:"楷体";`

注意点：

1\.如果取值是中文， 需要用双引号或者单引号括起来

2\.设置的字体必须是用户电脑里面已经安装的字体

**快捷键**

- ff font-family:;

> 1\. 如果设置的字体不存在，那么浏览器会使用默认的字体来显示。默认使用宋体
>
> 2\. 如果设置的字体不存在, 而我们又不想用默认的字体来显示怎么办?
> 可以给字体设置备选方案
> 格式: `font-family:"字体1", "备选方案1", ...;`
>
> 3\. 如果想给中文和英文分别单独设置字体, 怎么办?
>
> - 但凡是中文字体, 里面都包含了英文
> - 但凡是英文字体, 里面都没有包含中文
> - 也就是说中文字体可以处理英文, 而英文字体不能处理中文
>
> 注意：如果想给界面中的英文单独设置字体, 那么英文的字体必须写在中文的前面
>
> 4\. 在开发中常用的字体？
>
> - 中文: 宋体/黑体/微软雅黑
> - 英文: "Times New Roman"/Arial
>
> 还需要知道一点, 就是并不是名称是英文就一定是英文字体
> 因为中文字体其实都有自己的英文名称, 所以是不是中文字体主要看能不能处理中文
>
> - 宋体 SimSun
> - 黑体 SimHei
> - 微软雅黑 Microsoft YaHei

**字体属性的缩写格式**

```css
font: style weight size family;
例如:
font:italic bold 10px "楷体";
```

*注意点:*
1\. 在这种缩写格式中有的属性值可以省略

- sytle 可以省略
- weight可以省略

2\. 在这种缩写格式中 style 和 weight 的位置可以交换

3\. 在这种缩写格式中有的属性值是不可以省略的

- size 不能省略

- family 不能省略

4\. size 和 family 的位置是不能顺便乱放的
size 一定要写在 famil y的前面, 而且 size 和 family 必须写在所有属性的最后

**1\. 文本装饰的属性**

格式: ·text-decoration: underline;·

**取值:**

-underline 下划线
- line-through 删除线
- overline 上划线
- none 什么都没有, 最常见的用途就是用于去掉超链接的下划线

**快捷键:**

- td  text-decoration: none;
- tdu text-decoration: underline;
- tdl text-decoration: line-through;
- tdo text-decoration: overline;

2\.文本水平对齐的属性

格式: `text-align: right;`

取值:

- left 左
- right 右
- center 中

**快捷键**

- ta text-align: left;
- tar text-align: right;
- tac text-align: center;

3\. 文本缩进的属性

格式: `text-indent: 2em;`

取值:

2em, 其中 em 是单位, 一个 em 代表缩进一个文字的宽度

快捷键

- ti text-indent:;
- ti2e text-indent: 2em;

**文字的颜色属性**

1\. 在 CSS 中如何通过 color 属性来修改文字颜色

格式: `color: 值;`

**取值:**

2.1.1 英文单词

一般情况下常见的颜色都有对应的英文单词, 但是英文单词能够表达的颜色是有限制的, 也就是说不是所有的颜色都能够通过英文单词来表达

1.2 rgb

rgb其实就是三原色, 其中r(red 红色) g(green 绿色) b(blue 蓝色)

格式: rgb(0,0,0)

那么这个格式中的

第一个数字就是用来设置三原色的光源元件红色显示的亮度

第二个数字就是用来设置三原色的光源元件绿色显示的亮度

第三个数字就是用来设置三原色的光源元件蓝色显示的亮度

这其中的每一个数字它的取值是0-255之前, 0代表不发光, 255代表发光, 值越大就越亮

红色: rgb(255,0,0);
绿色: rgb(0,255,0);
蓝色: rgb(0,0,255);
黑色: rgb(0,0,0);
白色: rgb(255,255,255);

在前端开发中其实并不常用黑色

只要让红色/绿色/蓝色的值都一样就是灰色

而且如果这三个值越小那么就越偏黑色, 越大就越偏白色

例如: color: rgb(200,200,200);

1.3 rgba

rgba中的rgb和前面讲解的一样, 只不过多了一个a

那么这个 a 呢代表透明度, 取值是 0-1, 取值越小就越透明

例如: color: rgba(255,0,0,0.2);

1.4  十六进制

在前端开发中通过十六进制来表示颜色, 其实本质就是RGB

十六进制中是通过每两位表示一个颜色

例如: #FFEE00 FF表示R EE表示G 00表示B

十六进制和十进制转换的公式

1.5 十六进制缩写

在CSS中只要十六进制的颜色每两位的值都是一样的, 那么就可以简写为一位

例如:

#FFEE00 == #FE0

注意点:

1\. 如果当前颜色对应的两位数字不一样, 那么就不能简写

#123456;

2\. 如果两位相同的数字不是属于同一个颜色的, 也不能简写

#122334

#### 2. !important

作用：提升某个直接选中标签的选择器中的某个属性的优先级的, 可以将被指定的属性的优先级提升为最高

**注意点：**

1\. !important 只能用于直接选中, 不能用于间接选中
2\. 通配符选择器选中的标签也是直接选中的
3\. !important 只能提升被指定的属性的优先级, 其它的属性的优先级不会被提升
4\. ***!important 必须写在属性值的分号前面***
5\. !important 前面的感叹号不能省略

```css
*{
    color: blue !important;//将 color 属性的优先级提为最高。
    font-size: 10px;
}
```

### 4. 权重问题

1\. 什么是优先级的权重?

作用: 当多个选择器混合在一起使用时, 我们可以通过计算权重来判断谁的优先级最高

2\. 权重的计算规则

1. 首先先计算选择器中有多少个 id, id 多的选择器优先级最高
2. 如果 id 的个数一样, 那么再看类名的个数, 类名个数多的优先级最高
3. 如果类名的个数一样, 那么再看标签名称的个数, 标签名称个数多的优先级最高
4. 如果 id 个数一样, 类名个数也一样, 标签名称个数也一样, 那么就不会继续往下计算了, 那么此时谁写在后面听谁的，也就是说优先级如果一样, 那么谁写在后面听谁的

**注意点:**

1\. 只有选择器是直接选中标签的才需要计算权重, 否则一定会听直接选中的选择器的

### 5. div 和 span 标签

1\. 什么是 div?

作用: 一般用于配合 css 完成网页的基本布局

2\. 什么是span?

作用: 一般用于配合 css 修改网页中的一些局部信息

3\.div 和 span 有什么区别?

- div 会单独的占领一行,而 span 不会单独占领一行
- div 是一个容器级的标签, 而 span 是一个文本级的标签

4\. 容器级的标签和文本级的标签的区别?

- 容器级的标签中可以嵌套其它所有的标签
- 文本级的标签中只能嵌套文字/图片/超链接

容器级的标签
div h ul ol dl li dt dd ...

文本级的标签
span p buis strong em ins del ...

**注意点:**

哪些标签是文本级的哪些标签是容器级的, 我们不用刻意去记忆, 在企业开发中一般情况下要嵌套都是嵌套在 div 中, 或者按照组标签来嵌套

### 5\.CSS 的显示模式

- 在 HTML 中 HTML 将所有的标签分为两类, 分别是容器级和文本级
- 在 CSS 中 CSS 也将所有的标签分为两类, 分别是块级元素和行内元素

1\.什么是块级元素, 什么是行内元素?

块级元素会独占一行,行内元素不会独占一行

容器级的标签

div h ul ol dl li dt dd ...

文本级的标签

span p buis stong em ins del ...

块级元素

p div h ul ol dl li dt dd

行内元素

span buis strong em ins del

2\.块级元素和行内元素的区别?
1.块级元素

独占一行

如果没有设置宽度, 那么默认和父元素一样宽

如果设置了宽高, 那么就按照设置的来显示

2.行内元素

不会独占一行

如果没有设置宽度, 那么默认和内容一样宽

行内元素是不可以设置宽度和高度的

3.行内块级元素

为了能够让元素既能够不独占一行, 又可以设置宽度和高度, 那么就出现了行内块级元素

### 6. 转换 CSS 的显示模式

1\. 如何设置 CSS 的显示模式？

设置元素的 display 属性

2\. display 属性的取值

- block 块级
- inline 行内
- inline-block 行内块级

3\.快捷键

- di display: inline;
- db display: block;
- dib display: inline-block;

### 7. 背景

#### 1. 背景颜色

如何设置标签的背景颜色?

在CSS中有一个background-color:属性, 就是专门用来设置标签的背景颜色的

取值:

- 具体单词
- rgb
- rgba
- 十六进制

快捷键:

bgc background-color: #fff;

#### 2. 背景图片

##### 1, 设置背景图片

如何设置背景图片?

在 CSS 中有一个叫做 background-image: url(); 的属性, 就是专门用于设置背景图片的

*快捷键:*

bgi background-image: url();

**注意点:**
1.图片的地址必须放在url()中, 图片的地址可以是本地的地址, 也可以是网络的地址
2.如果图片的大小,没有标签大, 那么会自动在水平和垂直方向平铺来填充
3.如果网页上出现了图片, 那么浏览器会再次发送请求获取图片

 平铺效果图：

 ![Snipaste_2020-07-09_12-14-39](Snipaste_2020-07-09_12-14-39.png)

##### 2. 背景平铺

1\. 如何控制背景图片的平铺方式?

CSS 中有一个 background-repeat 属性, 就是专门用于控制背景图片的平铺方式的

取值:

- repeat 默认, 在水平和垂直都需要平铺
- no-repeat 在水平和垂直都不需要平铺
- peat-x 只在水平方向平铺
- peat-y 只在垂直方向平铺

快捷键

bgr background-repeat:

应用场景:

可以通过背景图片的平铺来降低图片的大小, 提升网页的访问速度

##### 3. 背景定位

1\.如何控制背景图片的位置?

在 CSS 中有一个叫做 background-position: 属性, 就是专门用于控制背景图片的位置

2\.格式:

background-position: 水平方向 垂直方向;

3\.取值

具体的方位名词

- 水平方向: left center right
- 垂直方向: top center bottom

具体的像素

- 例如: background-position: 100px 200px;
注意：
- 记住一定要写单位, 也就是一定要写px
- 记住具体的像素是可以接收负数的

快捷键:

bp/bgp background-position: 0 0;

注意点:

同一个标签可以同时设置背景颜色和背景图片, 如果颜色和图片同时存在, 那么图片会覆盖颜色

##### 4. 背景属性缩写 

1\.背景属性缩写的格式

background: 背景颜色 背景图片 平铺方式 关联方式 定位方式;

快捷键:

bg+ background: #fff url() 0 0 no-repeat;

2.注意点：
background 属性中， 任何一个属性都可以被省略

3.什么是背景关联方式？
默认情况下背景图片会随着滚动条的滚动而滚动， 如果不想让背景图片随着滚动条的滚动而滚动， 那么我们就可以修改背景图片和滚动条的关联方式

4.如何修改背景关联方式？
在CSS中有一个叫做background-attachment的属性， 这个属性就是专门用于修改关联方式的

格式
background-attachment：scroll;

取值：

- scroll 默认值， 会随着滚动条的滚动而滚动
- fixed 不会随着滚动条的滚动而滚动

快捷键:

ba background-attachment:;

#### 3. 背景图片和插入图片的区别

1\. 背景图片仅仅是一个装饰, 不会占用位置，插入图片会占用位置

2\. 背景图片有定位属性, 所以可以很方便的控制图片的位置；插入图片没有定位属性, 所有控制图片的位置不太方便

3\. 插入图片的语义比背景图片的语义要强, 所以在企业开发中如果你的图片想被搜索引擎收录, 那么推荐使用插入图片

### 8. CSS 精灵图

1\. 什么是CSS精灵图

CSS精灵图是一种图像合成技术

2\. CSS精灵图作用

可以减少请求的次数, 以及可以降低服务器处理压力

3.如何使用CSS精灵图

CSS的精灵图需要配合背景图片和背景定位来使用

### 9.边框属性

1\.  什么边框?
边框就是环绕在标周围的线条

2\. 边框属性的格式
2.1 连写(同时设置四条边的边框)
border: 边框的宽度 边框的样式 边框的颜色;

*快捷键:*
bd+ border: 1px solid #000;

**注意点:**

1. 连写格式中颜色属性可以省略, 省略之后默认就是黑色
2. 连写格式中样式不能省略, 省略之后就看不到边框了
3. 连写格式中宽度可以省略, 省略之后还是可以看到边框

2.2 连写(分别设置四条边的边框)

- border-top: 边框的宽度 边框的样式 边框的颜色;
- border-right: 边框的宽度 边框的样式 边框的颜色;
- border-bottom: 边框的宽度 边框的样式 边框的颜色;
- border-left: 边框的宽度 边框的样式 边框的颜色;

快捷键:

- bt+ border-top: 1px solid #000;
- br+
- bb+
- bl+

2.3 连写(分别设置四条边的边框)

- border-width: 上 右 下 左;
- border-style: 上 右 下 左;
- border-color: 上 右 下 左;

注意点:

1. 这三个属性的取值是按照顺时针来赋值, 也就是按照上右下左来赋值, 而不是按照日常生活中的上下左右
2. 这三个属性的取值省略时的规律
   1. 上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
   2. 上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
   3. 上 右 下 左 > 上 > 右下左边取值和上边一样

3.非连写(方向+要素)

- border-left-width: 20px;
- border-left-style: double;
- border-left-color: pink;

### 10. 内边框属性

1\. 什么是内边距?

边框和内容之间的距离就是内边距

2\. 格式

**非连写**

- padding-top: ;
- padding-right: ;
- padding-bottom: ;
- padding-left: ;

**连写**
padding: 上 右 下 左;

**这三个属性的取值省略时的规律**

- 上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
- 上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
- 上 右 下 左 > 上 > 右下左边取值和上边一样

**注意点:**
1\. 给标签设置内边距之后, 标签占有的宽度和高度会发生变化
2\. 给标签设置内边距之后, 内边距也会有背景颜色

### 11. 外边框属性

1\. 什么是外边距?

标签和标签之间的距离就是外边距

2\. 格式
**非连写**

- margin-top: ;
- margin-right: ;
- margin-bottom: ;
- margin-left: ;

**连写**
margin: 上 右 下 左;

2\. 这三个属性的取值省略时的规律

- 上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
- 上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
- 上 右 下 左 > 上 > 右下左边取值和上边一样

**注意点:**

外边距的那一部分是没有背景颜色的

**内外边距和并现象：**

在默认布局的垂直方向上, 默认情况下**外边距是不会叠加的, 会出现合并现象**, 谁的外边距比较大就听谁的

例如：

```html
样式设置为：
.hezi1{
	margin-right:50px;
}
.hezi2{
	margin-left:100px;
}

<span class="hezi1">我是span</span><span class="hezi2">我是span</span>
//上面的例子
.hezi1 和 .hezi2 水平方向上之间的外摆那句为 100px,而不是 100px + 50 px = 150px;
```

### 12. 盒子模型

1\. 什么是 CSS 盒子模型?
CSS 盒子模型仅仅是一个形象的比喻, HTML 中所有的标签都是盒子

**结论:**
在HTML中所有的标签都可以设置

- 宽度/高度  == 指定可以存放内容的区域
- 内边距  == 填充物
- 边框  == 手机盒子自己
- 外边距  == 盒子和盒子之间的间隙

**盒子模型的宽度和高度**

1\. 内容的宽度和高度
就是通过width/height属性设置的宽度和高度

2\. 元素的宽度和高度
宽度 = 左边框 + 左内边距 + width + 右内边距 + 右边框
高度 同理可证

3\. 元素空间的宽度和高度
宽度 = 左外边距 + 左边框 + 左内边距 + width + 右内边距 + 右边框 + 右外边距
高度 同理可证

***注意：内容宽高和元素宽高和元素空间宽高的区别***


要求：增加 padding 属性的值，要求元素的宽高不变：

规律：

1\. 增加了padding之后元素的宽高也会发生变化
2\. 如果增加了padding之后还想保持元素的宽高, 那么就必须减去内容的宽高

要求：增加 border 属性的值，要求元素的宽高不变：

规律：

1\. 增加了border之后元素的宽高也会发生变化
2\. 如果增加了border之后还想保持元素的宽高, 那么就必须减去内容的宽高

**box-sizing 属性**

1\. CSS3 中新增了一个 box-sizing 属性, 这个属性可以保证我们给盒子新增padding 和 border 之后, 盒子元素的宽度和高度不变

2\.box-sizing 属性是如何保证增加 padding 和 border 之后, 盒子元素的宽度和高度不变

和我们前面学习的原理一样, 增加 padding 和 border 之后要想保证盒子元素的宽高不变, 那么就必须减去一部分内容的宽度和高度

3\.box-sizing 取值

- content-box （默认值）元素的宽高 = 边框 + 内边距 + 内容宽高
- border-box：元素的宽高 = width/height的宽高

**要求将小盒子放到大盒子中, 并且让小盒子在大盒子中水平垂直居中**

两种方式设置大盒子的内边距，和设置小盒子的外边距

```html
.box1{
    width: 350px;
    height: 350px;
    background-color: darkmagenta;
    padding-top: 150px;
    padding-left: 150px;
    /*box-sizing: border-box;*/
    /*border: 1px solid #000;*/
}

.box2{
    width: 200px;
    height: 200px;
    background-color: cadetblue;
   //方式1 
	margin: 150px auto;
	//方式二：
	margin-top:150px;
	margin-left:150px;
    
}

<div class="box1">
    <div class="box2"></div>
</div>
```

注意点:

1\. 如果两个盒子是嵌套关系, 那么设置了里面一个盒子顶部的外边距, 外面一个盒子也会被顶下来

2\.如果外面的盒子不想被一起定下来,那么可以给外面的盒子添加一个边框属性

3\.在企业开发中, 一般情况下如果需要控制嵌套关系盒子之间的距离, 应该首先考虑padding, 其次再考虑margin

margin本质上是用于控制兄弟关系之间的间隙的

**补充：**

1\. 在嵌套关系的盒子中, 我们可以利用 margin: 0 auto; 的方式来让里面的盒子在外面的盒子中水平居中

2\. margin: 0 auto; 只对水平方向有效, 对垂直方向无效

**盒子水平居中和内容水平居中**

- text-align: center;	作用:设置盒子中存储的文字/图片水平居中

- margin:0 auto;	作用:让盒子自己水平居中(相对于父标签)

### 13. 清空默认边框

1\. 为什么要清空默认边距(外边距和内边距)

在企业开发中为了更好的控制盒子的宽高和计算盒子的宽高等等, 所以在企业开发中, 编写代码之前第一件事情就是清空默认的边距

2.如何清空默认的边距

格式

```html
*{
            margin: 0;
            padding: 0;
}
```

缺点：

通配符选择器会找到(遍历)当前界面中所有的标签, 所以性能不好

企业开发中可以从这个网址中拷贝

http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css

或

```css
源碼為

<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">
//清空默认的文本格式
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.18.1/build/cssreset-context/cssreset-context-min.css">
```

### 14. 行高和字号

1\. 什么是行高（line height）?

在 CSS 中所有的行都有自己的行高

**注意点:**

- 行高和盒子高不是同一个概念
- 行高指的是每行内容的高度
- 盒子高指的是标签元素的高度

规律:

1\. 文字在行高中默认是垂直居中的

2\. 在企业开发中我们经常将盒子的高度和行高设置为一样, 那么这样就可以保证一行文字在盒子的高度中是垂直居中的
简而言之就是: 要想一行文字在盒子中垂直居中, 那么只需要设置这行文字的"行高等于盒子的高"即可

3.在企业开发中如果一个盒子中有多行文字, 那么我们就不能使用设置行高等于盒子高来实现让文字垂直居中, 只能通过设置 padding 来让文字居中

**还原字体和字号**

注意点:
1\. 在开发中, 如果一个盒子中存储的是文字, 那么一般情况下我们会以盒子左边的内边距为基准, 不会以右边的内边距为基准, 因为这个右边的内边距有误差

2\. 右边内边距的误差从何而来? 因为右边如果放不下一个文字, 那么文字就会换行显示, 所以文字和内边距之间的距离就有了误差

3\. 顶部的内边距并不是边框到文字顶部的距离, 而是边框到行高顶部的距离

> 编写网页：
>
> 1\. 清空所有的边距
> 2\. 从外向内, 从上至下的编写网页

### 15. 网页布局的方式

1\. 什么是网页的布局方式?

网页的布局方式其实就是指浏览器是如何对网页中的元素进行排版的

#### 1\. 标准流(文档流/普通流)排版方式

1. 其实浏览器默认的排版方式就是标准流的排版方式

2. 在CSS中将元素分为三类, 分别是块级元素/行内元素/行内块级元素

   在标准流中有两种排版方式, 一种是垂直排版, 一种是水平排版

   - 垂直排版, 如果元素是块级元素, 那么就会垂直排版
   - 水平排版, 如果元素是行内元素/行内块级元素, 那么就会水平排版

#### 2. 浮动流排版方式

1\. 浮动流是一种"半脱离标准流"的排版方式

2\. 浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐

注意点:

1\. 浮动流中没有居中对齐, 也就是没有 cente r这个取值

2\. 在浮动流中是不可以使用 margin: 0 auto;

**特点:**
1\. 在浮动流中是不区分块级元素/行内元素/行内块级元素的

无论是级元素/行内元素/行内块级元素都可以水平排版

2\. 在浮动流中无论是块级元素/行内元素/行内块级元素都可以设置宽高

3.综上所述, 浮动流中的元素和标准流中的行内块级元素很像

3.定位流排版方式

**浮动元素的脱标**

1\. 什么是浮动元素的脱标？

- 脱标: 脱离标准流
- 当某一个元素浮动之后, 那么这个元素看上去就像被从标准流中删除了一样, 这个就是浮动元素的脱标

2\. 浮动元素脱标之后会有什么影响？

如果前面一个元素浮动了, 而后面一个元素没有浮动 , 那么这个时候前面一个元就会盖住后面一个元素

**浮动元素的排序规则**

1\. 相同方向上的浮动元素, 先浮动的元素会显示在前面, 后浮动的元素会显示在后面

2\. 不同方向上的浮动元素, 左浮动会找左浮动, 右浮动会找右浮动

3\. 浮动元素浮动之后的位置, 由浮动元素浮动之前在标准流中的位置来确定

**浮动元素的贴靠现象？**

什么是浮动元素贴靠现象?

1\. 如果父元素的宽度能够显示所有浮动元素, 那么浮动的元素会并排显示

2\. 如果父元素的宽度不能显示所有浮动元素, 那么会从最后一个元素开始往前贴靠

3\. 如果贴靠了前面所有浮动元素之后都不能显示, 最终会贴靠到父元素的左边或者右边

简而言之：就是一行显示不了所有的元素的，就会换一行显示，向贴靠浮动，就向那个方向贴靠，如果下一行还是显示不了，接着向下一行贴靠。

**浮动元素围字现象**

什么是浮动元素字围现象?

*浮动元素不会挡住不浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置*，这个就是浮动元素字围现象

**扩展**

1\. 开发中什么时候使用标准流什么时候使用浮动流?

垂直方向使用标准流, 水平方向使用浮动流

2\. 拿到一个很复杂的界面如何入手?

1. 从上至下布局
2. 从外向内布局
3. 水平方向可以先划分为一左一右再对左边或者右边进行进一步布局

**浮动元素的高度问题**

1\. 在标准流中内容的高度可以撑起父元素的高度
2\. 在浮动流中浮动的元素是不可以撑起父元素的高度的

### 14. 清除浮动

**方式一：**

给前面一个父元素设置高度

注意：
在开发中, 我们能不写高度就不写高度, 所以这种方式用得很少

**方式二：**

给后面的盒子添加clear属性

clear属性取值:

- none: 默认取值, 按照浮动元素的排序规则来排序(左浮动找左浮动, 右浮动找右浮动)
- left: 不要找前面的左浮动元素
- right: 不要找前面的右浮动元素
- both: 不要找前面的左浮动元素和右浮动元素

注意：
当我们给某个元素添加 clear 属性之后, 那么这个属性的marg in属性就会失效

原因：因为它所在组的标签的父标签为 body, 如果想要有效果那么就需要body 显示边框，在开发中不会给 body 设置边框，所以不 margin 会失效

**方式三：**

隔墙法

*外墙法*

1\. 在两个盒子中间添加一个额外的块级元素
2\. 给这个额外添加的块级元素设置 clear: both;属性

注意点:

1\. 外墙法它可以让第二个盒子使用margin-top属性
2\. 外墙法不可以让第一个盒子使用margin-bottom属性

*内墙法*

1\. 在第一个盒子中所有子元素最后添加一个额外的块级元素
2\. 给这个额外添加的块级元素设置clear: both;属性

注意点:

1\. 内墙法它可以让第二个盒子使用margin-top属性
2\. 内墙法它可以让第一个盒子使用margin-bottom属性

*外墙法和内墙法区别?*

外墙法不能撑起第一个盒子的高度, 而内墙法可以撑起第一个盒子的高度

***在企业开发中不常用隔墙法来清除浮动***

**方式四：**

利用伪元素清除浮动

本质上就是内墙法, 只不过是直接通过CSS代码添加了内墙, 其它特性和内墙法都一样

*注意点:*
IE6中不支持这种方式, 为了兼容IE6必须给前面的盒子添加*zoom:1;属性

**方式五：**

overflow: hidden;作用
1\. 可以将超出标签范围的内容裁剪掉
2\. 清除浮动
3\. 可以通过overflow: hidden;让里面的盒子设置margin-top之后, 外面的盒子不被顶下来

### 16. 定位

**定位流分类：**

1\. 相对定位
2\. 绝对定位
3\. 固定定位
4\. 静态定位

#### 相对定位

*1\. 什么是相对定位？*

相对定位就是相对于自己以前在标准流中的位置来移动

*2\. 相对定位注意点*

1\. 相对定位是不脱离标准流的, 会继续在标准流中占用一份空间
2\. 在相对定位中同一个方向上的定位属性只能使用一个
3\. 由于相对定位是不脱离标准流的, 所以在相对定位中是区分块级元素/行内元素/行内块级元素
4\. 由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位的元素设置margin/padding等属性的时会影响到标准流的布局

*3.相对定位应用场景*

- 用于对元素进行微调
- 配合绝对定位使用

```css
            position: relative;
            top: 20px;
            left: 20px;
//现在元素所在的位置，在原元素在标准流中的位置，向下 20px,向右 20px
```

#### 绝对定位

1\. 什么是绝对定位?

绝对定位就是相对于body来定位

2\. 绝对定位注意点

1. 绝对定位的元素是脱离标准流的
2. 绝对定位的元素是不区分块级元素/行内元素/行内块级元素

```css
            position: absolute;
            left: 0;
```

**绝对定位参考点**

1\. 默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以body作为参考点

2\. 如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点

1. 只要是这个绝对定位元素的祖先元素都可以
2. 指的定位流是指绝对定位/相对定位/固定定
3. 定位流中只有静态定位不行

3\. 如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 而且祖先元素中有多个元素都是定位流, 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点

**注意点：**

1\. 如果一个绝对定位的元素是以 body 作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点

2.一个绝对定位的元素会忽略祖先元素的 padding

**子绝父相**

- 相对定位弊端： 相对定位不会脱离标准流, 会继续在标准流中占用一份空间, 所以不利于布局界面
- 绝对定位弊端：默认情况下绝对定位的元素会以body作为参考点, 所以会随着浏览器的宽度高度的变化而变化
-  子绝父相
   子元素用绝对定位, 父元素用相对定位

**绝对定位水平居中**

1\. 如何让绝对定位的元素水平居中
只需要设置绝对定位元素的 left:50%;
然后再设置绝对定位元素的 margin-left: -元素宽度的一半px;

#### 固定定位

1\. 什么是固定定位?
固定定位和前面学习的背景关联方式很像, 背景定位可以让背景图片不随着滚动条的滚动而滚动, 而固定定位可以让某个盒子不随着滚动条的滚动而滚动

**注意点:**

1. 固定定位的元素是脱离标准流的, 不会占用标准流中的空间

2. 固定定位和绝对定位一样不区分行内/块级/行内块级
3. IE6不支持固定定位

#### z-index属性

1\. 什么是z-index属性?

默认情况下所有的元素都有一个默认的z-index属性, 取值是 0.

z-index属性的作用是专门用于控制定位流元素的覆盖关系的

- 默认情况下定位流的元素会盖住标准流的元素
- 默认情况下定位流的元素后面编写的会盖住前面编写的
- 如果定位流的元素设置了z-index属性, 那么谁的z-index属性比较大, 谁就会显示在上面

**注意点:**
1\.从父现象

- 如果两个元素的父元素都没有设置 z-index 属性, 那么谁的 z-index 属性比较大谁就显示在上面
- 如果两个元素的父元素设置了z-index属性, 那么子元素的z-index属性就会失效, 也就是说谁的父元素的z-index属性比较大谁就会显示在上面

### 17. a 标签的伪类选择器。

通过我们的观察发现a标签存在一定的状态、

- 默认状态, 从未被访问过
- 被访问过的状态
- 鼠标长按状态
- 鼠标悬停在a标签上状态

*什么是a标签的伪类选择器?*

a标签的伪类选择器是专门用来修改a标签不同状态的样式的

*格式*

- :link 修改从未被访问过状态下的样式
- :visited 修改被访问过的状态下的样式
- :hover 修改鼠标悬停在a标签上状态下的样式
- :active 修改鼠标长按状态下的样式

**注意点**

1\. a标签的伪类选择器可以单独出现也可以一起出现

2\. 标签的伪类选择器如果一起出现, 那么有严格的顺序要求

编写的顺序必须要个的遵守爱恨原则 love hate

3\. 如果默认状态的样式和被访问过状态的样式一样, 那么可以缩写

### 18. 过渡

过渡三要素

- 必须要有属性发生变化
- 必须告诉系统哪个属性需要执行过渡效果
- 必须告诉系统过渡效果持续时长

**注意点**

当多个属性需要同时执行过渡效果时用逗号隔开即可

```
transition-property: width, background-color;/*告诉系统哪个属性需要执行过渡效果*/
transition-duration: 5s, 5s;
 /*告诉系统过渡效果持续的时长*/
 /*告诉系统过渡动画的运动的速度*/
            transition-timing-function: linear;
            /*告诉系统延迟多少秒之后才开始过渡动画*/
            /*transition-delay: 2s;*/
```

1\. 过渡连写格式
`transition: 过渡属性 过渡时长 运动速度 延迟时间;`

**注意点**

- 和分开写一样, 如果想给多个属性添加过渡效果也是用逗号隔开即可
- 连写的时可以省略后面的两个参数, 因为只要编写了前面的两个参数就已经满足了过渡的三要素
- 如果多个属性运动的速度/延迟的时间/持续时间都一样, 那么可以简写为
  transition:all 0s;

**编写过渡套路**

1\. 不要管过渡, 先编写基本界面

2\. 修改我们认为需要修改的属性

3\. 再回过头去给被修改属性的那个元素添加过渡即可

### 19. 2D转换模块

***transform***

**romate()**

```css
/*其中deg是单位, 代表多少度*/
            transform: rotate(45deg);
顺时针旋转 45 度，以中心为旋转点
```

**transform()**

```css
            /*
            第一个参数:水平方向
            第二个参数:垂直方向
            */
            transform: translate(100px, 0px);
```

**csale()**

```css
            /*
            第一个参数:水平方向
            第二个参数:垂直方向
            注意点:
            如果取值是1, 代表不变
            如果取值大于1, 代表需要放大
            如果取值小于1, 代表需要缩小
            如果水平和垂直缩放都一样, 那么可以简写为一个参数
            */
            /*transform: scale(0.5, 0.5);*/
            transform: scale(1.5);
```

 注意点:
 1\. 如果需要进行多个转换, 那么用空格隔开
  2\. 2D的转换模块会修改元素的坐标系, 所以旋转之后再平移就不是水平平移的

#### 形变中心点

 默认情况下所有的元素都是以自己的中心点作为参考来旋转的, 我们可以通过形变中心点属性来修改它的参考点

`transform-origin: left top;`

- 第一个参数:水平方向
- 第二个参数:垂直方向

**注意点**

取值有三种形式

- 具体像素
- 百分比
- 特殊关键字

#### 旋转轴向

1\. 什么是透视

近大远小

2\.注意点

一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面

默认情况下所有元素都是围绕 Z 轴进行旋转

想围绕哪个轴旋转, 那么只需要在rotate后面加上哪个轴即可

`transform: rotateY(45deg);`

横X 纵Y 平面Z

### 20. 阴影

1\. 如何给盒子添加阴影

box-shadow: 水平偏移 垂直偏移 模糊度 阴影扩展 阴影颜色 内外阴影;

2.注意点

1\. 盒子的阴影分为内外阴影, 默认情况下就是外阴影
2\. 快速添加阴影只需要编写三个参数即可
box-shadow: 水平偏移 垂直偏移 模糊度;

默认情况下阴影的颜色和盒子内容的颜色一致

3\. 如何给文字添加阴影

text-shadow: 水平偏移 垂直偏移 模糊度 阴影颜色 ;

### 21. 动画模块

1\. 过渡和动画之间的异同
**不同点**

- 过渡必须人为的触发才会执行动画

- 动画不需要人为的触发就可以执行动画

**相同点**

- 过渡和动画都是用来给元素添加动画的
- 过渡和动画都是系统新增的一些属性
- 过渡和动画都需要满足三要素才会有动画效果

## JavaScript

###　第一章　Java Script 简介

##### 1\. JavaScript 诞生背景

在上世纪九十年代，互联网正处于发展初期，从拨号上网（在那时绝大多数的因特网用户都使用速度仅为28.8kbits/s的“猫”[调制解调器]上网）到低配置的家用电脑，上网比做任何事情都需要耐心。为完成简单的表单验证操作而频繁地与服务器交换数据，只会加重用户的负担。例如：提交表单 30 秒后，却告诉您输入的值不合法。因此需要一种客户端语言，用来处理这种简单验证。

##### 2\. JavaScript 诞生的目的以及现在的用途

处理一些以前由服务器负责的一些表单输入验证操作。在 JavaScript 诞生以前需要把表单数据发送到服务器端才能验证用户是否没有填写必填项，是否输入无效或不合法的值。

现在 JavaScript 用途:

① 表单验证

② 与浏览器及其网页等几乎所有方面的交互。

> JavaScript 的文件后缀名 js

##### 3\. JavaScript 简史

NetSpace 公司 Brendan Eich 布兰登.艾奇计划于 1995 年 2 月发布的 NetSpace Navigator2 开发一种名为 LiveScript 的脚本语言——该语言将同时在浏览器（客户端）和服务端使用（在服务器端的名字叫做LiveWire）。

**为什么这门语言叫 JavaScript？**

为了赶在发布日期前完成对 JavaScript 的开发，Netspace 与 Sun 公司建立了一个开发联盟。在发前夕，为了蹭 Java 的热度，临时把 LiveScript 改名 JavaScript。

##### 4\. JavaScript 标准化

背景

JavaScript1.0 获得了巨大的成功，Netspace 公司紧接又推出了 JavaScript1.1 版。同时，微软公司也向IE浏览器投入更多的资源。之后IE浏览器在 IE3 中加入名为 JScript 的实现（为了避免与Netspace 公司的授权问题。）

微软推出之后，意味着 JavaScript 有了两个完全不同的版本：Netspace Navigator中 的 JavaScript，和微软的 Inernet Explorer 中的 JScript.,由于当时还没有标准规定 JavaScrip t的语法和特性。因此 JavaScript 的标准化被提上了日程。

1997 年以 JavaScript1.1 为蓝本的建议提交给了 ECMA（欧洲计算机制造商协会，European Cmpuler Manufacturers Association）。该协会指定 39 号技术委员会（TC39，Technical Committee）负责标准化一种通用，跨平台供应商中立的脚本语言的语言和语义。

TC39 由来自微软、Netspace、Sun、Borland 以及来自其他关注脚本语言发展公司的公司的程序员组成。经过数月的努力终于完成了 ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准。

第二年 ISO/IEC（Ineternational Organization for Standardization and International Electrotechnical Commission,国际标准化组织和国际电工委员会）也采用了 ECMAScript 作为标准（ISO/IEC-16262）

##### 4\. JavaScript的组成：

- 核心（ECMASript)，由 ECMA-262 定义，提供核心语言功能。
- 文档对象模型（DOM Document Object Model） 提供访问和操作操作网页内容的 API
- 浏览器对象模型（BOM Browers Object Model ）提供与操作浏览器交互的方法和接口

##### 5\. ECMAScript

ECMAScript 定义的只是 JavaScript 语言的基础。在此基础之上，可以构建更完善的脚本语言。Web浏览器只是 ECMAScript 实现的宿主环境之一.宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境交接交互。

ECMAScript 的组成部分：语法、类型、语句、关键字、保留字、操作符、对象

ECMAScript 的版本：

- ECMAScript-262 第二版: 为了和 ISO/IEC-16262 保持一致，没有任何新增、修改、删除。
- ECMAScript-262 第三版：第一次进行修改。修改内容涉及字符串处理、错误定义、和数值输。新增正则表、新控制语句、try-catch 异常的处理，为围绕标准的国际化做了一些小修改。标志着 ECMAScript 称为了一门真正的编程语言
- ECMAScript-262 第四版：进行全面检核修订。强类型类变量、新语句、新数据结构、真正的类、继承、还定于与数据交互的新方式。与 ECMAScrpt-262 第三版相比，几乎是一门全新的语法。正式发布前被抛弃

- ECMAScript-262 第五版(2009年推出)：支持 Unicode 编码（支持多语言开发，即标识符可以为非英文），对象称为了平台无关的。新增原生 JSON 对象（用于解析和序列化 JSON 数据），继承的方法和高级属性、严格模式。

##### 6\. DOM 文档对象模型

① 定义：DOM （Document Object Model 文档对象模型），是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API application Programming Interface）。DOM 把整个文档映射为一个多层点结构。通过 DOM 开发人员可以添加、删除、替换或修改任何节点，控制页面内容和结构的主权。

② 为什么要使用 DOM？

Internet Explorer 4 和 Netspace Navigator 5 分别支持不同的  DHTML(Dynamic Hyper Text Markup Lanauage)，开发人员无需重网页，就可以修改外观和融了。然而，由于 Netspace 和 微软再开发 Dhtml 方面各抒己见，带来兼容性问题（不能够编写一个 HTML 在不同浏览器中运行）。如果不对微软和网景加以控制，那么 Web 开发领域就会出现两强割据，浏览器不能兼容。因此负责指定 Web  通信标准 W3C（World Wide Web Consortium 万维网联盟） 开始着手于规划 DOM

③ DOM 级别。

**DOM1** (DOM level 1)级 于 1998 年 10 月成为 W3C 的推荐标准。DOM1 有两个模块构成：DOM 核心（DOM core）和 DOM HTML。

1. DOM核心（dom core）：规定如何映射基于XML的文档结构，简化对节点访问和操作。
2. DOM HTML 模块： 添加了针对 HTML 的对象和方法。
3. DOM 视图（DOM Views）:跟踪不同文档的视图接口。
4. DOM 事件（DOM Events）：事件和事件的处理接口。
5. DOM 样式（DOM Style）: CSS 为元素应用样式的接口
6. DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。
7. DOM加载和保存（DOM Load and Save）: 验证文档的方法---在DOM验证（DOM Vaildation

注：DOM , 并不是只针对于 JavaScript，很多别的编程语言也实现了 DOM。

DOM1  的主要目标：映射文档结构。

**DOM2** ：在 DOM1 级别上扩充了鼠标和用户界面事件、范围、遍历 DOM 文档节点方法等细分模块。而且通过对象接口增加了对 CSS 的支持。

**DOM3**: 支持 XML 1.0 规范、涉及 XML Infoset、XPath 和 XML Base

**其他 DOM 标准**

1. SVG1.0（Scalable Vector Graphic）可伸缩矢量图。
2. MathML1.0(Mathematical Markup Language)数学标记语言。
3. SMIL（Synchronized Multimedia Integtation Language）同步多媒体集成语言。

##### 7\. 浏览器对象模型 BOM

支持访问和操作浏览器口的浏览器对象模型 BOM (Borwser Object Model)。提供与浏览器交互的方法和接口

针对浏览器的JavaScript 扩展:

1\. 弹出新浏览器窗口

2\. 移动缩放关闭浏览器窗口的功能，

3\. 提供浏览器详细信息的navigator对象。

4\. 提供浏览器锁甲页面的详细信息的location对象。

5\. 提供用户显示器的分辨率详细信息的screen

6\. 对cookies的支持。

7\. 像XMLHttpRequest和navigator对象。

##### 8\. 总结: 

JavaScript 是一种专门为网页交互设计的脚本语言。主要由三部分组成：

- 核心（ECMASript)，由 ECMA-262 定义，提供核心语言功能。
- 文档对象模型（DOM Document Object Model） 提供访问和操作操作网页内容的 API
- 浏览器对象模型（BOM Browers Object Model ）提供与操作浏览器交互的方法和接口

**JavaScript 是一门脚本、单线程、解释型、弱类型语言。**

> 单线程：JavaScript 是解析一行执行一行。不能并发执行不同的代码
>
> 弱类型：在程序执行之前不需要编译，在运行时边解析边执行
>
> 强类型：在程序执行之前，需要编译，把程序编译为机器语言的程序，比如.exe文件
>
> 解释型：类型可变
>
> 编译型：定义变量时，类型就已经确定且不可改变

**特点：**

- 交互性
- 安全性(不允许直接访问本地硬盘)
- 跨平台性（**只要浏览器可以解释 JS，都可以执行**）

### 第二章 在 JavaScript 中如何使用 JS

##### 1\. Script 元素

向 HTML 页面中插入 JavaScript 的主要方法就是插入 script  元素。

① 常用属性：

- async。可选。表示立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或加载其他脚本。*只对外部文件有效。*
- defer：表示脚本可以延迟到文档完全解释和显示之后执行。指对外部脚本文件有效。
- src: 可选。表示包含执行代码外部脚本文件。也可以引用外部域的文件，不建议
- type：可选。取值为 `text/javascript`。该属性不是必要，如果没有指定该属性，则其默认值仍为 text/JavaScript

② 使用 script 元素的方式

- 页内式 (在页面中直接嵌入) 

  ```html
  <script type="text/javascript">
      一些代码
  </script>
  ```

- 外链式  eg:<script src="">

虽然可以使用上面两种。但是要符合 web 标准（w3c标准中的一项）:结构（html）,样式（css）,行为（js）相分离，因此通常会采用外链式。

script 元素内部的 JavaScript 代码将被从上至下依次解释，保存在自己的环境中。在其所有的代码解释(包括下载)之前，页面中的其余内容均不会被浏览器加载或执行。

注意: 

① 代码中的任何地方不要出现 "</script>"，否则会误认为那是结束的 <\script> 标签。从而产生错误。代码中要用 <\/script> 代替

② 不能再 HTML 中使用类似于 `<script type="text/javascript" src="example.js" />` 这种语法。因为这种语法不符合 HTML 规范，而且也不能得到某些浏览器的正确解析。

一个 script 标签，只能一种方式引入。如果同时使用，则会下载并执行外部的脚本文件，嵌入的代码会失效

> 不使用 script 元素。在 HTML 页面中使用 JavaScript 的方法。
>
> 在 HTML 标签的适当位置直接使用。例如：行内式 eg:<button  onclick="alert('今天天气很好！‘)">
>
> Tips:
>
> 外部 JavaScript 的 .js 扩展名，不是必须的。因为浏览器不会假警察 JavaScript 文件的扩展名。因此可以使用其他编程语言进行生成。但服务器通常需要查看扩展名决定响应应用那种类型(HTTP 协议中服务器通常需要响应的文件类型)

##### 2\. script 标签的位置

按照传统，所有的 script 元素应该放在页面的 <head> 元素中。目的：把所有的引用文件放在相同的地方。但是这种做法意味着必须等待把 script 中的素有代码解释和执行完成之后，才能呈现页面的内容。(遇到 body 标签才开始呈现页面的内容)

这种做法，对于有很多 javascript 代码的页面来说，这无疑会导致浏览器再呈现页面时出现明显的延迟。解决办法，把全部 script 标签及其引用放置再 body 元素中内容的后面。

**网页是从上至下加载，而 js 代码通常是给标签添加交互(操作 html 或 CSS)，所以需要先加载HTML（因此放在 body 标签的底部）。**

**使用延迟脚本**

使用 script 中的 defer 属性。浏览器立即下载但等到页面解析完成之后(遇到 </html> 标签后执行)解释执行。

`<script type="text/javascript" defer="defer" src="example.js">`

> defer 属性只适用于外部脚本文件。HTML5 规范要求脚本按照出现先后顺序执行，也就是第一个延迟脚本会优先于第二个脚本执行。而脚本会优先于 DOMContentLoaded 事件执行。在现实中延时脚本中并不一定会按照顺序执行，也不一定会在 DOMcontentLoaded 事件触发前执行。因此一个页面最好只包含一个延时脚本。
>
> IE4~IE7还支持对嵌入脚本的 defer 属性，但 IE8 及之后的脚本就完全支持 HTML5 的规定行为。

##### 3\. 异步脚本

使用 async 属性。表示立即下载文件

① 只适用于外部脚本。

② 异步脚本，并不保证按照指定先后顺序执行。因此，需确保异步脚本之间互不依赖。

不让页面等待脚本的下载和执行，从而异步加载页面其他内容。在加载期间不要修改 DOM。

举例：`<script type="text/javascript" async="async" src="example.js"></script>`

> 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件前后执行。

##### 4\. 动态加载脚本

因为 JavaScript 可以使用 DOM API，所以可以通过 DOM 动态添加 script 元素、加载指定的脚本。

```javascript
//创建一个 script 元素并将其添加到 DOM 即可
let script = document.createElement('script');
script.src = 'example.js';
document.head.appendChild(script);
/*把 HTMLElement 元素添加到 DOM 且执行到这段代码之前不会发送请求。默认情况下，
以这种方式创建的<script>元素是以异步方式加载的，相当于添加了 async 属性。不过这样做可能会
有问题，因为所有浏览器都支持 createElement()方法，但不是所有浏览器都支持 async 属性。因此，
如果要统一动态脚本的加载行为*/
```

同步加载：

```javascript
let script = document.createElement('script');
script.src = 'example.js';
script.async = false;
document.head.appendChild(script); 
```

以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先 级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些 动态请求文件的存在，可以在文档头部显式声明它们：

`<link rel="preload" href="example.js">`

##### 5\. 在 XHTML （Extensible HTML 可拓展超文本编辑语言）中的用法：

```javascript
<script type="text/javascript">
    function compare(a,b){
    	if(a < b){
            alert("A is less than B");
        }else if (a > b){
            alert("A is greater than B");
        }else{
            alert("A is equals B");
        }
	}
</script>
```

在 HTML 中可以使用，但在 XHTML 中 < 会被当作一个新标签的来解析。但是作为标签，小于号后面不能有空格。

解决办法：

① 使用字符实体 \&lt; 来替换代码中的小于号

② 使用 CData 片段来包含 javascript 代码。在 XHTML （XML）中 CData 区域是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。举例：

```javascript
<script type="text/javascript">
    		//<![CDATA[
                function comapare(a,b){
                    if(a < b){
                        alert("A is less than B");
                    }else if (a > b){
                        alert("A is greater than B");
                    }else{
                        alert("A is equals B");
                    }
            	}
		//]]>
</script>
```

在兼容 XHTML 中浏览器中可以被正常识别。但有些有浏览器不支持 CData 片段。因此需要对其进行注释。按照约定，这种格式在所有的浏览器就都可以使用了。

##### 6\. 嵌入代码与外部文件的比较

使用外部文件的优点：

① 可维护性： 把所有的 JavaScript 文件都放在同一个文件夹下，便于维护。而不用代开每个 HTML 页面来修改 JavaScript 代码进行维护。

② 可缓存：浏览器能够根据设置缓存链接的所有外部文件。即如果多个页面使用同一个文件。那么该文件只需要加载一次。

③ 适应未来：通过外部文件来包含 JavaScript 无需使用 XHTML 或注释 hack。 HTML 和 XHTML 的外部文件语法相同。

结论: 尽可能使用外部文件来包含 JavaScript 代码

##### 7\. 文档模式

混杂模式和标准模式。不同模式主要影响 CSS 内容的呈现，有时也会影响到 CSS 的执行。

> 混杂模式会让 IE 的行为与 IE5(包含非标准特性) 相同。而标准模式， IE 行为接近标准

如果文档开始处没有文档类型声明，则默认开启混杂模式。但采用混在模式，如果不采用 hack 技术，跨浏览器的行为根本没有一致性可言(兼容性问题)。

*准标准模式* 浏览器特性都符合标准。不标准体现在各个浏览器的 HTML 标签控件之间的间隙。

开启标准模式:

```HTML
<!-- HTML 4.0.1 严格型-->
<!DOCTYPE html "-//W3C//DTD HTML 4.01 //EN"
 "http://www.w3.org/TR/xhtml4/DTD/xhtml1-strict.dtd">
<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//w3c//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE html>
```

准标准模式：

```html
准标准模式可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发。准标准模式和标准模式非常接近。
<!-- XHTML 1.0 过渡型 -->
<!DOCTYPE html PUBLIC
"-//w3c//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- XHTML 框架集型 -->
<!DOCTYPE html PUBLIC
"-//w3c//DTD XHTML 1.0 Frameset//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-Frameset.dtd">
<!-- HTML 4.0.1 过渡型-->
<!DOCTYPE html "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/xhtml4/DTD/loose.dtd">
<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//w3c//DTD XHTML 1.0 Frameset//EN"
"http://www.w3.org/TR/xhtml1/DTD/frameset.dtd">
```

##### 8\. noscript 标签

`<noscript> 您的浏览器不支持JavaScript，或者您禁用脚本。</noscript>`

脚本被禁用就会显示这条信息。当浏览器执行脚本这条内容不会显示，尽管它是文档的一部分。

### 第三章  基本概念

##### 1\. 语法

① 区分大小写

② 标识符的命名规则同 Java。首字母小写，其余单词的首字母大写

③ 注释：

- 单行注释 eg：//一行代码
- 多行注释 eg：/* 一些代码*/

多行注释可以嵌套单行注释，但不可以嵌套多行注释。但尽量注释之间不要互相嵌套

④ 严格模式

在严格模式下，不确定的行为得到处理，不安全的操作的将会抛出错误。在脚本中使用严格模式，需要在顶部添加：`"use strict"`

在函数内部使用

> “use strict”; 是一个编译知识。告诉支持的 JavaScript 引擎切换到严格模式。

⑤ 语句

一条语句（指令）以分号结尾。如果省略分号，则由 JavaScript 解析器确定语句的结尾。

> 虽然语句的结尾的分号不是必须的，但是任何时候都不要省略分号。因为这个分号可以避免很多错误。
>
> 1. 可以避免不完整的输入。
> 2. 可以删除多余的空格，来压缩代码。
> 3. 加上分号在某些情况下，可以提升代码的性能，这样解析器就不用推测、确定在哪里加上分号了。

##### 2\.  关键字和保留字

关键字：一组约定好，具有特定用途的单词。不可以用作标识符。 

```javascript
break do in typeof case else instanceof var catch export new void class extends return while const finally super with continue for switch yield debugger function this default if throw delete import try
```

保留字: 一组约定好，未来可能是关键字的单词。同样不能用作标识符：

- 始终保留: `enum `
- 严格模式下保留: `implements package public interface protected static let private` 
- 模块代码中保留: `await`

##### 3\.  变量

定义变量，在内存中分配一块存储空间给变量，以便存储数据。

ECMAScript 变量是松散类型的，意思是变量可以用于**保存任何类型的数据**。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。

① var

```javascript
var message;//定义了一个名为 message 的变量
var message = "hi";//，message 被定义为一个保存字符串值 hi 的变量.像这样初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已。随后，不仅可以改变保存的值，也可以改变值的类型

var message = "hi";
message = 100; // 合法，但不推荐
```

1\. var 声明的作用域

使用 var 操作符定义的变量会成为包含它的函数的局部变量。就是声明 var 所在的花括号中，如果没有花括号，那么就是全局变量。不过，在函数内定义变量时省 略 var 操作符，可以创建一个全局变量：

```javascript
function test() {
 message = "hi"; //省略 var 操作符，就相当于创建了一个全局变量
}
/*
虽然可以通过省略 var 操作符定义全局变量，但不推荐这么做。在局部作用域中定
义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 var 是不是有意而
为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。
*/
```

2\. 如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：

```javascript
var message = "hi",
 found = false,
 age = 29;//插入换行和空格缩进并不是必需的，但这样有利于阅读理解，也可以省略缩进和空格例如：
var message = "hi",found = false,age = 29;
```

3\. var 声明提升

“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次 使用 var 声明同一个变量也没有问题

```javascript
//反复声明一个变量
function foo() {
 var age = 16;
 var age = 26;
 var age = 36;
 console.log(age);
}
foo(); // 36 
//声明提升的例子
function foo() {
 console.log(age);
 var age = 26;
}
foo();// undefined,因为这里并没有给 age 赋值
//等价于
function foo() {
 var age;
 console.log(age);
 age = 26;
}
foo();// undefined
```

② let 声明

let 声明的范围是块作用域， 而 var 声明的范围是函数作用域

```javascript
if (true) {
 var name = 'Matt';
 console.log(name); // Matt
}
console.log(name); // Matt 
if (true) {
 let age = 26;
 console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义
```

var 如果在函数的某个地方定义了那么在该函数的任何位置都就可以引用。而 let 声明的变量则不可以。因为它的作用域仅限于该块内部。

注意：

1\. let 也不允许同一个块作用域中出现冗余声明（也就是重复命名同一个标识符的变量）。这样会导致报错。

```javascript
let age;
let age; // SyntaxError；标识符 age 已经声明过了
//JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域。嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明：

let age = 30;
console.log(age); // 30
if (true) {
 let age = 26;
 console.log(age); // 26
} 
//对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。
var name;
let name; // SyntaxError
let age;
var age; // SyntaxError 
因为 let 声明的变量不会允许在同一个块中出现冗余声明
```

2\. let 声明的变量不会再作用域中被提升。

```javascript
// name 会被提升
console.log(name); // undefined
var name = 'Matt';
// age 不会被提升
console.log(age); // ReferenceError：age 没有定义
let age = 26; 
```

在 let 声明之前的执行瞬间被称为“**暂时性死区**”（temporal dead zone），在此 阶段引用任何后面才声明的变量都会抛出 ReferenceError

3\. 全局声明

使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声 明的变量则会）。

```javascript
var name = 'Matt';
console.log(window.name); // 'Matt'
let age = 26;
console.log(window.age); // undefined
```

4\.条件声明

在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合 并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同 时也就不可能在没有声明的情况下声明它

```javascript
// 假设脚本不确定页面中是否已经声明了同名变量
 // 那它可以假设还没有声明过
 var name = 'Matt';
 // 这里没问题，因为可以被作为一个提升声明来处理
 // 不需要检查之前是否声明过同名变量
 let age = 36;
 // 如果 age 之前声明过，这里会报错

//使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块
// 假设脚本不确定页面中是否已经声明了同名变量
 // 那它可以假设还没有声明过
 if (typeof name === 'undefined') {
 	let name;
 }
 // name 被限制在 if {} 块的作用域内
 // 因此这个赋值形同全局赋值
 name = 'Matt';
 try {
 	console.log(age); // 如果 age 没有声明过，则会报错
 } catch(error) {
 	let age; 
  }
 // age 被限制在 catch {}块的作用域内
 // 因此这个赋值形同全局赋值
 age = 26; 
```

不能使用 let 进行条件式声明

4\. for 循环中的 let 声明

```javascript
//var 定义的迭代变量会渗透到循环体外部
for (var i = 0; i < 5; ++i) {
 // 循环逻辑
}
console.log(i); // 5
//let 定义的迭代便令仅限于 for 循环内部。
for (let i = 0; i < 5; ++i) {
 // 循环逻辑
}
console.log(i); // ReferenceError: i 没有定义
//在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值
for (var i = 0; i < 5; ++i) {
 setTimeout(() => console.log(i), 0)
}
// 你可能以为会输出 0、1、2、3、4
// 实际上会输出 5、5、5、5、5
//在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。
for (let i = 0; i < 5; ++i) {
 setTimeout(() => console.log(i), 0)
}
// 会输出 0、1、2、3、4=
```

③ const 声明

声明变量时必须同时初始化变量（赋值），且无法再次进行修改。也就是说声明的是常量。

注意：

1\. 不许云冗余声明。即不可以声明相同标识符的变量。

2\. 声明的作用域也是块

3\. const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象， 那么修改这个对象内部的属性并不违反 const 的限制。

4\. 不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每 次迭代只是创建一个新变量。

④ 声明风格及最佳实践

1\. 不使用 var

2\. const 优先，let 次之

> 使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因 意外赋值导致的非预期行为

Tips:  如果定以后没有初始化则是 Undefined。没有定义变量则是 null

##### 4. 数据类型

1\. 简单类型与复杂类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型

   Undefined、Null、Boolean、Number、 String 、Symbol

- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型

​    通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等。Function

> Object 是一种无序名值对的集合
>
> Symbol（符号）是 ECMAScript 6 新增的

2\. 堆和栈

堆栈空间分配区别：

- 栈：运行环境自动分配释放存放函数的参数值、局部变量的值等
- 堆：一般由程序员分配释放，若程序员不释放，由垃圾回收机制释放回收。

简单数据类型存放到栈里面，复杂数据类型存放到堆里面。

注意：JavaScript 中没有堆栈的概念，通过堆栈的方式，可以更容易理解代码的一些执行方式，便于之后学习其他语言

3\. 简单数据类型与复杂数据类型传参的区别

简单数据类型

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部变量

```javascript
function fn(a) {
            a++;
            console.log(a); //11
        }
        var x = 10;
        fn(x);
        console.log(x); //10
```

复杂数据类型

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```javascript
// 复杂数据类型传参
        function Person(name) {
            this.name = name;
        }

        function f1(x) {
            console.log(x.name); //刘德华
            x.name = "张学友";
            console.log(x.name); //张学友
        }
        var p = new Person("刘德华");
        console.log(p.name); //刘德华
        f1(p);
        console.log(p.name); //张学友
```

4\. typeof 操作符

因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。在 JS 中查看数据类型可以通过 typeof 操作符进行查看，typeof 会将检查结果以字符串的形式返还给我们。

- "undefined"表示值未定义； 
- "boolean"表示值为布尔值； 
- "string"表示值为字符串；
- "number"表示值为数值； 
- "object"表示值为对象（而不是函数）或 null； 
- "function"表示值为函数； 
- "symbol"表示值为符号。

```javascript
let message = "some string";
console.log(typeof message); // "string"
console.log(typeof(message)); // "string" 
```

typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。调用 typeof null 返回的是"object"。这是因为特殊值 null 被认为是一个对空对象的引用。

> 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

5\. Undefined 类型

Undefined 类型只有一个值，就是特殊值 undefined。声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。

```javascript
let message;
console.log(message == undefined); // true
//比较message 和 undefined 的字面值时，两者是相等的。等同于下面的
let message = undefined;
console.log(message == undefined); // true
//字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。
例1：
let message; // 这个变量被声明了，只是值为 undefined
// 确保没有声明过这个变量
// let age
console.log(message); // "undefined"
console.log(age); // 报错
```

对未声明的变量，只能执行一个 有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用， 实际上在严格模式下会抛出错误。）

在对未初始化的变量调用 typeof 时，返回的结果是"undefined"，但对未声明的变量调用它时， 返回的结果还是"undefined"，这就有点让人看不懂了。

```javascript
let message; // 这个变量被声明了，只是值为 undefined
// 确保没有声明过这个变量
// let age
console.log(typeof message); // "undefined"
console.log(typeof age); // "undefined"
```

> 注意 即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的 同时进行初始化。这样，当 typeof 返回"undefined"时，你就会知道那是因为给定的变 量尚未声明，而不是声明了但未初始化。

undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多 其他可能的值同样是假值。所以一定要明确自己想检测的就是 undefined 这个字面值，而不仅仅是假值。

```javascript
let message; // 这个变量被声明了，只是值为 undefined
// age 没有声明
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
}
if (age) {
 // 这里会报错
} 
```

6\. Null 类型

Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 "object" 的原因：

```javascript
let car = null;
console.log(typeof car); //'object'
//undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，
console.log(null == undefined); // true
```

> 在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。可能不会用到。
>
> if (car != null) { // car 是一个对象的引用 } 

null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。

```javascript
let message = null;
let age;
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
} 
if (age) {
 // 这个块不会执行
}
if (!age) {
 // 这个块会执行
} 
```

7\. Boolean 类型

Boolean 类型有两个字面值：true 和 false （区分大小写）。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。要将一个其 他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：

```javascript
let message = "Hello world!";
let messageAsBoolean = Boolean(message); //true
```

Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true 或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。

| 数据类型  | 转换为 true 的值 | 转换为 false 的值 |
| --------- | ---------------- | ----------------- |
| Boolean   | true             | false             |
| String    | 非空字符串       | “”空字符串        |
| Number    | 非零数值         | 0、NaN            |
| Object    | 任意对象         | Null              |
| undefined | N/A(不存在)      | undefined         |

像 if 等流控制语句会自动执行其他类型值到布尔值的转换。举例：

```javascript
let message = "Hello world!";
if (message) {
 console.log("Value is true");//Value is true
}
```

8\. Number 类型

Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。

**① 整数**

整数可以使用的不同进制表示：二进制、八进制、十进制、十六进制字面量表示。

**二进制**

要创建二进制字面量，必须让真正的数值前缀 0b（区分大小写），然后是十六进制数字（1,2）。

```javascript
let binaryNum1 = 0b11;
```

**八进制**

对于八进制字面量， 第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应 有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数：

```javascript
let octalNum1 = 070; // 八进制的 56
let octalNum2 = 079; // 无效的八进制值，当成 79 处理
let octalNum3 = 08; // 无效的八进制值，当成 8 处理
```

注意：八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。

**十六进制**

要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0~9 以 及 A~F）。十六进制数字中的字母大小写均可。

```javascript
let hexNum1 = 0xA; // 十六进制 10
let hexNum2 = 0x1f; // 十六进制 31
```

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

**② 浮点数**

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不 是必须有整数，但推荐加上。

```javascript
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐

//因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数
let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理

//对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。例如：
let floatNum = 3.125e7; // 等于 31250000
let floatNum = 3e-17; // 0.000 000 000 000 000 03
//默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如，0.000 000 3 会被转换为 3e7）。
```

> 浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。
>
> 例如下面的例子

```javascript
if (a + b == 0.3) { // 别这么干！
 console.log("You got 0.3.");
} 
//这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。
注意 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript
所独有。其他使用相同格式的语言也有这个问题
```

**值的范围**

- 表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；
- 可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。
- 可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的 数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无 穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正 无穷大）表示。
- 如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的 最小值和最大值之间），可以使用 isFinite()函数，如下所示：

```javascript
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false

//虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。

//使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负 Infinity。没错，这两个属性包含的值分别就是-Infinity 和 Infinity。
```

③ NaN 

非法数字 NAN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执 行。但在 ECMAScript 中，0、+0 或 0 相除会返回 NaN：

```javascript
console.log(0/0); // NaN
console.log(-0/+0); // NaN
//如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity 
```

NaN 的特性：

- 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）
- NaN 不等于包括 NaN 在内的任何值。例如：`console.log(NaN == NaN); // false`

isNaN() 函数

该函数接收一个参数，可以是任意数据类型，然后判断 这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的 值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回 true。

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1
```

> isNaN()函数，此时，首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法， 并测试其返回值。

**数值转换**

有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是 转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

Number() 函数基于如下规则执行转换：

- 布尔值，true 转换为 1，false 转换为 0
- 数值，直接返回。
- null，返回 0
- undefined，返回 NaN。
- 字符串
  - 如果字符串*包含*数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number("1")返回 1，Number("123")返回 123，Number("011")返回 11（忽略前面 的零）。
  - 如果字符串*包含*有效的浮点值格式如"1.1"，包括数值字符前面带加、减号的情况,则会转换为相应的浮点值（同样，忽略前面的零）。
  - 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整 数值。
  - 如果是空字符串（不包含字符），则返回 0。如果字符串包含除上述情况之外的其他字符，则返回 NaN
- 对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。

```javascript
let num1 = Number("Hello world!"); // NaN
let num2 = Number(""); // 0
let num3 = Number("000011"); // 11
let num4 = Number(true); // 1
//一元加操作符与 Number()函数遵循相同的转换规则
```

ParseInt()

转换规则：

字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。。比如， "1234blue"会被转换为 1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为 22，因为小数 点不是有效的整数字符。

假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八 进制、十六进制）。

```javascript
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10，解释为十六进制整数
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70，解释为十进制值
let num6 = parseInt("0xf"); // 15，解释为十六进制整数
//不同的数值格式很容易混淆，因此 parseInt()也接收第二个参数，用于指定底数（进制数）。
let num = parseInt("0xAF", 16); // 175 
let num1 = parseInt("AF", 16); // 175 提供了十六进制参数，那么字符串前面的"0x"可以省掉：
let num1 = parseInt("10", 2); // 2，按二进制解析
let num2 = parseInt("10", 8); // 8，按八进制解析
let num3 = parseInt("10", 10); // 10，按十进制解析
let num4 = parseInt("10", 16); // 16，按十六进制解析

因为不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给
它第二个参数。
```

parseFloat()

都是从位置 0 开始检测每个字符。解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有 效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，"22.34.5"将转换 成 22.34。终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式。十六进制数值始终会返回 0。因为 parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小 数点后面只有一个零），则 parseFloat()返回整数。

```javascript
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); // 31250000
```

④ String 类型

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（"）、 单引号（'）或反引号（`）表示：

```javascript
let firstName = "John";
let lastName = 'Jacob';
let lastName = `Jingleheimerschmidt`;
注意：以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。
```

字符字面量：

- \t 制表 
- \b 退格 
- \r 回车 
- \f 换页 
- \\\ 反斜杠（\） \' 单引号（'），在字符串以单引号标示时使用，例如'He said, \'hey.\''
- \\" 双引号（"），在字符串以双引号标示时使用，例如 "He said, \"hey.\"" \
- \`反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\`` 
- \xnn 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于"A" 
- \unnnn 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字 符"Σ"

注：字符字面量作为单个字符被解释。例如：

```javascript
let text = "This is the letter sigma: \u03a3.";//即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。
console.log(text.length); // 28 
```

字符串的长度可以通过其 length 属性获取。返回字符串中 16 位字符的个数。如果字符串中包含双字节字符，那么length 属性返回的值可能不是准确的字符数。

特点：不可变性。字符串一旦创建就不可以修改。

**转换为字符串的两种方法：**

toString()方法，返回当前值的字符串等价物。字符串值也有 toString()方法， 该方法只是简单地返回自身的一个副本。null 和 undefined 值没有 toString()方法

```javascript
//用于数值、布尔值、对象和字符串值
let age = 11;
let ageAsString = age.toString(); // 字符串"11"
let found = true;
let foundAsString = found.toString(); // 字符串"true"
```

，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十 进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基 数的字符串表示

```javascript
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a" 
注意，默认情况下（不传参数）的输出与传入参数 10 得到的结果相同。
```

不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表 示相应类型值的字符串。String()函数遵循如下规则。 

- 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。 
- 如果值是 null，返回"null"。 
- 如果值是 undefined，返回"undefined"。

```javascript
let value1 = 10;
let value2 = true;
let value3 = null;
let value4;
console.log(String(value1)); // "10"
console.log(String(value2)); // "true"
console.log(String(value3)); // "null"
console.log(String(value4)); // "undefined"
```

**模板字面量**

使用反引号。模板字面量保留换行字符，可以跨行定义字符串。模板字面量会保持反引号内部的空格

```javascript
let myMultiLineString = 'first line\nsecond line';
let myMultiLineTemplateLiteral = `first line
second line`;
console.log(myMultiLineString);
// first line
// second line"
console.log(myMultiLineTemplateLiteral);
// first line
// second line
console.log(myMultiLineString === myMultiLinetemplateLiteral); // true
//上面两种定义方式效果相同
```

使用模板字面量定义模板

```javascript
let pageHTML = `
<div>
 <a href="#">
 <span>Jake</span>
 </a>
</div>`;
// 这个模板字面量在换行符之后有 25 个空格符
let myTemplateLiteral = `first line
 second line`;
console.log(myTemplateLiteral.length); // 47 
//模板字面量会保持反引号内部的空格
// 这个模板字面量以一个换行符开头
let secondTemplateLiteral = `
first line
second line`;
console.log(secondTemplateLiteral[0] === '\n'); // true
// 这个模板字面量没有意料之外的字符
let thirdTemplateLiteral = `first line
second line`;
console.log(thirdTemplateLiteral);
// first line
// second line
```

**字符串插值**

模板字面量支持字符串插值。也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的 是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作 用域中取值。

字符串插值通过 `${}` 使用

```javascript
let value = 7;
let exponent = 'second';
// 以前，字符串插值是这样实现的：
let interpolatedString - value + ' to the ' + exponent + ' power is ' + (value * value);
// 现在，可以用模板字面量这样实现：
let interpolatedTemplateLiteral =
 `${ value } to the ${ exponent } power is ${ value * value }`;
console.log(interpolatedString); // 5 to the second power is 25
console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
//所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：
//在插值表达式中可以调用函数和方法：
function capitalize(word) {
 return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}
console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!
//模板也可以插入自己之前的值：
let value = '';
function append() {
 value = `${value}abc`
 console.log(value);
}
append(); // abc
append(); // abcabc
append(); // abcabcabc
```

**模板字面量标签函数**

模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。

标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。标签函数 接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求 值得到的字符串。

```javascript
let a = 6;
let b = 9;
function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
 console.log(strings);
 console.log(aValExpression);
 console.log(bValExpression);
 console.log(sumExpression);
 return 'foobar';
}
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""] 字符串插值是插在里面的因此数组前后都是空字符串
// 6
// 9
// 15
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "foobar" 
//因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：
let a = 6;
let b = 9;
function simpleTag(strings, ...expressions) {
 console.log(strings);
 for(const expression of expressions) {
 	console.log(expression);
 }
 return 'foobar';
}
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(taggedResult); // "foobar" 
//对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：
let a = 6;
let b = 9;
function zipTag(strings, ...expressions) {
 return strings[0] +
 expressions.map((e, i) => `${e}${strings[i + 1]}`)
 .join('');
}
//map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "6 + 9 = 15" 
```

**原始字符串**

使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数：

```javascript
// Unicode 示例
// \u00A9 是版权符号
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9
// 换行符示例
console.log(`first line\nsecond line`);
// first line
// second line
console.log(String.raw`first line\nsecond line`); // "first line\nsecond line" 

// 对实际的换行符来说是不行的
// 它们不会被转换成转义序列的形式
console.log(`first line
second line`);
// first line
// second line
console.log(String.raw`first line
second line`);
// first line
// second line
```

以通过标签函数的第一个参数，即字符串数组的.raw 属性取得每个字符串的原始内容

```javascript
function printRaw(strings) {
 console.log('Actual characters:');
 for (const string of strings) {
 console.log(string);
 }
 console.log('Escaped characters;');
 for (const rawString of strings.raw) {
 console.log(rawString);
 }
}
printRaw`\u00A9${ 'and' }\n`;
// Actual characters:
// ©
//（换行符）
// Escaped characters:
// \u00A9
// \n 
```

###### Ⅶ Symbol 类型

Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

① 符号的基本用法 

符号需要使用 Symbol()函数初始化。因为符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。

```javascript
let sym = Symbol();
console.log(typeof sym// symbol
//调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：
```

###### Ⅷ Object 类型

ECMAScript 中的对象其实就是一组数据和功能的集合。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法。创建语法：

```javascript
//ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，那么完全可以省略括号（不推荐）
let o = new Object();\
let o = new Object; // 合法，但不推荐
//ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在

//Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象
```

每个 Object 实例都有如下属性和方法。

- constructor：用于创建当前对象的函数
- hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属 性。要检查的属性名必须是字符串（如 o.hasOwnProperty("name")）或符号。
- isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。
- propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。
- toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。

> 严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏 览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象 不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。

##### 5\. 操作符




3. JavaScript 常用语句

1\. 可以接受任意类型的数据，弹出提示框，显示信息。alert();
2\. 在控制台输出消息，一般用来调试程序。console.log();
3\. 在网页中弹出输入框，一般用于接受用户输入的信息。prompt();
4\. 在网页中弹出提示框，显示信息，该方法一般与if判断语句配合使用。confirm()  与alert相比多了一个取消选项。



### 第二章 数据类型

> 数据是指所有能输入到计算机并被计算机程序处理的符号的总称，具有一定意义的数字、字母、符号和模拟量等的通称。

#### 1\. 六种基本数据类型

- 引用类型：Array、Object、function 

#### 2. Number 数字类型

注意点：
2\. 非法数字NAN（Not A Number）
3\. 在JS中中对数数值进行计算后当结果结果不是数值时，则返回NAN (eg:"中国" + 1000；)
4\. console.warn警告输出，console.error错误输出

Number 类型的注意点：


#### 3. String 字符串类型

字符串有双引号和单引号括住

**注意点**：

1\. 引号必须成对出现，不能一单一双
2\. 相同引号不能嵌套，不同引号可以嵌套。
3\. JS中整数的运算可以保证精确的结果,在JS中浮点数的运算可能得到不精确的结果。

#### 4. Null 、Undefine、NaN

- undefind 表示声明了变量，但变量未赋值（没有赋予初始值）
- null 类型 **空值** 只有一个值 null,undefined值实际上由 null 值衍生出来的，所以null=undefined

> 从语义上看 null 是以个空对象，所以使用 typeof 对 nul 进行判断后返回的是 Object.

#### 第三章  数据类型转换

在 JavaScript 中 Boolean、Number、String 的原始值都是伪对象。也就是说他们可以具有属性和方法。

#### 1. 其它数据类型转换为字符串

**toString()**

- 将其他类型的数据转换为字符串类型。
- 格式：`对象.toString();`

注意：

1\. null 和 undefined 没有内置 toString() 方法，如果强行调用则会报错
2\. toString不会影响到原变量，只是将转换的结果返回。

> Number 类型的 toString 方法有两种模式：默认模式和基模式。
> 默认模式：用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）。
> 注意：采用默认模式返回的数值都是十进制的。
基模式：可以用不同的基输出数字。eg: num.toString(16);
**String()**

- 与String()一样，只不过可以将null和undefined转换为字符串。
- 格式：`String(要转换的数据)；`

**“”**
任何数据和""用 + 连接到一起都会转换为字符串，其内部实现原理和String();一样。

####  2. 字符串转数字

**Number()函数**

- 如果是纯数字的字符串，则直接将其转换为数字。
- 如果字符串中有非数字的内容则转换为NaN
- 如果字符串是一个空串或者是一个全是空格的字符串则转换为0
- undefined 转为数字为 NaN，null 转为数字为 0，true 转换为为数字是1，false 转换为数字为 0

注意：在 Number 函数中无论混合字符串是否存在有效整数都会返回NaN

**parseInt()和parseFloat()函数**

parseInt()和parseFloat()函数的区别：前者只能提取整数，后者可以提取小数

parseInt()提取字符串中的整数

- 从第一位有效数字开始，直到遇到无效数字。如果第一位不是有效数字则返回NaN
- **第一个参数是要转换的字符串，第二个参数要转换的数字的进制（转换之后为"十进制"）**

parseInt基模式：可以把任何进制的字符串转化为整数

如果包含前导零，最好采用基10，这样才不会意外得到八进制。

在es5.0以上的版本中不支持解析八进制和十六进制。

parseFloat()提取字符串中的小数

- 会解析第一个小数点.遇到第二个.或者非数字结束
- 不支持第二个参数，只能解析十进制数
- 如果第一位不是有效数字则反返回NaN
- 如果解析的数据只有整数，则解析成整数。

#### 3. 强制类型转换：

**Number(value):**

**Boolean(value):**

**String(value):**

### 第四章 运算操作符

#### 1. 运算符的分类

按照功能划分：

- 算术运算符
- 位运算符
- 关系运算符
- 逻辑运算符

按照操作个数划分：

- 单目运算符（只有一个操作数的运算符）eg:++ --、

- 双目运算符 (有两个操作数的运算符) eg: + - \* / % 、

- 三目运算符 (有三个操作数的运算符) eg: a > b ? 1 ：0； 

#### 2. 运算符的优先级

JavaScript 中的优先级分为 15 级，1 级最高，15 级最低。在表达式中优先级高先于优先级低的进行运算。

<img src=clipboard.png>

运算符的结合规则：

在 JavaScript 中各种运算符的结合性分为两种：

- 左结合性：(自左至右) eg:先左后右 eg: x - y + z
- 右结合性：(自右至左) eg:x = y = z = 10; 三目

#### 3. 加法运算符

1\. 非 Number 类型的值进行运算时，会将这些值转换为Number类型的值在进行运算。
2\. 任何值和NaN做运算都是NaN
3\. 任何值和字符串做加法运算，都会先转换为字符串，再和字符串做字符串的拼接。

注意：除法运算，如果除数为零则结果是NaN,如果被除数为零，则结果为0.

####　5. 正负运算符

- 正运算符不会对数值做出改变，会把非 Number 类型的值转换为Number类型的值。
- 负运算符对数字进行取反

####　4. 赋值运算符：

**简单赋值运算符：=**

注意：赋值运算符左边只能是变量。多个赋值运算符可以组成赋值表达式具备右结合性。

**复合赋值运算符：+= -= *= /= %= 

由于赋值运算符时右结合性，所以先计算等号右边，再进行赋值运算。**

自增自减运算符：略

#### 5. 关系运算符

关系运算符存在的意义：
默认情况下，程序中每一句正确的代码都会被正确的执行。但是在某些情况下，我们需要在某个条件成立的情况下才执行一段的代码。

注意：

1\. 对非数值进行比较时，会先转换为数值再进行比较。
2\. 如果符号的两端都是字符串，则不会将其转换为数值进行比较。而会比较字符串的 unicode 码。
3\. null、undefined、NaN比较 。NaN与任何值不相等

isNaN判断是否是一个非数。eg:isNaN(num)

####　6. 逻辑运算符

> 在 JavaScript 语言中，所有的变量，都可以作为一个 boolean 类型的变量来使用。
>
> 只有 0、 null、undefined、“”(空串)为 false，其余皆为真

**&& 运算：**

两种情况：

- 第一种：当表达式权为真的时候，返回最后一个表达式的值

- 第二种：当表达式中，有一个为假的时候，返回第一个为假的表达式的值

**|| 运算**

- 第一种：当表达式权为假的时候，返回最后一个表达式的值
- 第二种：当表达式中，有一个为真的时候，返回第一个为真的表达式的值

#### 7. 逗号运算符

- 把多个表达式连接起来组成一个表达式，叫做逗号表达式。
- 格式：`表达式1，表达式2，表达式3……表达式n.`
- 求值过程：从表达式1开始计算，依次到表达式n.整个逗号表达式的值是最后一个表达式的值

注意：
1\. 并不是所有出现逗号的地方，都是逗号表达式，例如在变量声明中，逗号仅仅起到了一个间隔符的作用。
2\. 在程序中使用逗号表达式，通常是要求各个表达式的值，而不是求最后一个表达式（整个逗号表达式）的值。

#### 8. 比较运算符、

| 名称   | 符号 | 比较原理                                       |
| ------ | ---- | ---------------------------------------------- |
| 等于   | ==   | 做字面值的比较                                 |
| 全等于 | ===  | 除了比较字面值之外，还会比较两个变量的数据类型 |

全等于 === 除了比较字面值之外，还会比较两个变量的数据类型

###  第五章 数组和函数

####  1. 创建数组的方式

**使用 Array 构造函数**

```javascript
var arr = new Array();创建一个空数组 
var arr2 = new Arrary(20);创建一个长度为20的数组（里面可以放20个数据）。
var arr3 = new Array("asdf","小计"，23);
```

**使用数组字面量**

```javascript
var arr4 = [];创建一个空数组
var arr5 = ["asdf","小计"，23]；
```

**注意：**

1. 数组中存储的数据可以是任何类型（String/Number/Boolean…）
2. 可以根据需要向数组中添加任意数量的值。

#### 2.数组的常用操作

**ength:求数组的长度**

格式：数组名.length

*应用*

可以通过修改数组的长度来改变数组中元素的个数。如果变小了就从后面删除元素。

如果获取数组中元素是，数组名[索引值]，没有指定索引（或值没有那么多），系统不会报错，而是给定值为undefined

其它常用方法：

- join("separator") 把数组中的元素组成一个字符串，以separaotr作为分隔符，（若参数省略的话，则用默认用逗号作为分隔符，该方法只接受一个参数即分隔符）
- push()  接受任意数量的参数，把他们逐个天加数组的末尾，并返回修改后数组的长度
- pop() 数组末尾移除最后一项，减少数组的length值（length -1），并返回删除的移除项
- shift() 删除数组第一项，并返回删除的值，如果数组为空则返回undefined
- unshift() 将参数添加到数组的开头，并返回数组的长度。
- reverse() 反转数组的顺序
- concat() 将参数添加到元素数组中。会先复制当前数组，然后将接受的参数添加到这个 copy 数组的末尾，然后返回新构建的数组。在没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回
- indexOf() 接受两个参数:要查找的项和（可选的）表示查找起点位置索引（）；从数组的开头（位置0）开始向后查找
- lastindexOf()接受两个参数：要查找的项和表示查找起点位置的索引；其中，从数组的末尾开始向前查找。

这两个方法都返回要查找的项在数组中的位置，或者在没找到情况下返回-1；在比较第一个参数与数组中的每一项时，会使用全等操作符。

**push()和concat()的区别：**

```javascript
push()和concat()的区别：
eg: var  arr = [11,23,34,345];
var conpyarr = arr.concat(["zs","ls"]);//  [11,23,34,345,"zs","ls"];
arr.push(["zs","ls"]);// [11,23,34,345,["zs","ls"]];
```

### 第六章 函数

- 声明格式： function  函数名(参数…){函数体}`
- 表达式声明方式：`var sum = function(形参){}`
- 使用函数构造函数：var add = new Function('console.log(1+3);');
- 函数调用：函数名（实参…）；

注意：在其他编程语言中形参和实参个数必须相一致，在JavaScript中实参和形参个数可以不相等。

arguments 对象：包含了传入函数中的所有参数，arguments 并不是一个数组，只是与数组相似。除了拥有 length 属性，数组的所有属性和方法都不具备，arguments 对象还有一个名叫 callee 属性，该属性是一个指针,arguments 的 length 属性：函数形参的个数

```javasript
arguments.length;//获取参数个数
arguments[i];//获取第 i 个参数的值
```



注意：
- 如果函数没有使用 return 语句，那么函数有默认的返回值 undefined。
- 如果函数使用 return 语句，但是 return 后面没有任何值，那么函数函数返回的值也是 undefined
- 如果函数使用了 return 语句，那么跟在 return 语句后面的值，就成了函数的返回值。

函数直接声明和函数表达式声明的区别：

JavaScript 解析器首先把当前作用域的函数声明提前到整个作用域的最前面。（而函数表达式不会）

推荐的做法，要么让函数始终都返回一个值（有效的值），要么永远都不要返回值。

注意：JavaScript 中并没有重载，如果两个函数的参数名相同，后面写的函数，会对前面的函数覆盖

####　匿名函数：

用途：

- 用在绑定事件的时候。document.onclick ={alert("")}
- 定时器：
```javascript
setInterval{function(){
console.log("你打我啊！")；
},1000}
```
- 自调用函数：（function(){})()

函数是一种数据类型,属于Object.

**回调函数：**

回调函数就是一个通过函数调用的函数。

如果我们把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用器所指向的函数时，（在一个函数中调用另一个函数）我们就说这是回调函数。
一般用于递归。

#### 自定义 Object 对象

对象的定义

```javascript
var 变量名 = new Object();//对象实例
变量名.属性 = 值；//定义一个属性
变量名.函数名 = function();//定义一个函数
```

对象的访问

```javascript
对象.属性/方法
```

**花括号形式的自定义对象**

格式：

```javascript
var 变量名 = {
    属性名:值，
    属性名：值，
    函数名：function(){}
}
```

注意：属性之间用逗号隔开

var 变量名 = {}`

### 第七章 JS 中的事件

1\. 什么是事件?

事件是电脑输入设备与页面进行交互的响应，我们称之为事件。

2\. 常用的事件：

- enload 加载完成事件								常用于做页面 JS 代码初始化的操作
- onclick 单击事件
- onblur 失去焦点事件                                 常用于输入框失去焦点后，验证其输入内容是否合法
- onchange 内容发生改变事件                    常用于下拉列表和输入框内容发生改变后的操作
- onsubmit 表单提交事件                           常用于表单提交前，验证所有表单项是否合法

事件的注册又分为静态注册和动态注册两种：

什么是事件的注册(绑定)？

其实就是告诉浏览器，当事件响应后要执行哪些操作代码。

**静态注册事件**：

通过 html 标签的属性直接赋予事件响应后的代码。这种方式我们成为静态

**动态注册事件：**

通过 js 代码得到标签的 dom 对象，然后通过 dom 对象.时间名 这种形式指定事件响应后的代码，叫动态注册

动态注册基本步骤：

1. 获取标签对象
2. 标签对象.事件名 = function(){}

onsubmit 事件

```
<form action="url" method="get" onsubmit="return false">//return false 可以阻止提交
//静态
function onsubmitFun(){
	alert("表单项不合法");
	return false;
}

<form action="url" method="get" onsubmit="return onsubmitFun();">

```

### 第八章  DOM 模型

DOM 全称是 Document Object Model 文档对象模型

把文档中的标签、属性、文章，转换为对象进行管理

> 每个载入浏览器的 HTML 文档都会成为 document对象; document 可以对 HTML中的所有元素进行访问，常用操作有:增、删、改、查；
>
> document 对象是 window 对象的一部分，可通过window.docuemt 属性对其进行访问。

#### 1\. Document 对象

Document 对象对应整个页面。

#### 2. Document 中对象的方法

- getElementById(String elementId)；通过 id 属性查找标签对应的 dom 对象，
- getElementByName(String elementName); 通过 name 属性查找标签对应的 dom 对象
- getElementByTagName(String tagName); 通过标签名称查找 dom 对象
- createElement(tagName); 通过给定的标签名，创建一个标签对象

document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName 

以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象。

#### 3\. 节点的常用属性和方法

节点就是标签对象

添加一

### 第九章 BOM 模型