# Java 编程

[TOC]



## 第一章 Java 语言概述

##### 1.1 软件开发介绍

**1\. 软件开发**

- 软件：一系列按照特定顺序组织的计算机数据与指令的集合。
- 软件开发：制作软件
- 软件分类：应用软件和系统软件

指令是对数据进行操作或处理，而数据则是在指令或程序中定义或引用的数据。

**2\.人机交互**

人机交互其实就是使用软件的方式：

- 图形化界面（GUI Graphical User Interface 通过鼠标操作，可以看到过程）简单直观、使用容易接受，容易上手操作
- 命令行方式 （CLI Command Line  Interface）需要一个控制台，需要输入特定的指令，让计算机完成一些操作。较为麻烦，需要记住一些命令。

注：图形界面的抄袭历程：施乐>>苹果>>微软

> Pascal 之父 Nickiaus Wirth: "Aigorithms + Data Structures = Programs" //算法＋数据结构 = 程序

3\. **DOS 常用命令**：

进入 DOS ：Windows + R 然后再对话框中输入 cmd 点击确认 (Enter 键也可以): 

- md (make directory)创建目录：`md/mkdir fileName`

  只能新建文件夹

- dir  查看当前目录下的文件及文件夹

- rd 删除目录(只可以删除空文件夹)

- del 删除文件:`del 文件名称.文件类型`

- cd  进入当前盘符指定的指定目录：`cd 路径` 如果想要进入*其他盘符*指定的路径，则需要先进入其他盘符，然后再使用 cd 指令 注：`cd..` 返回上一级目录”	`cd\`直接退回当前文件所在盘符根目录

- exit 退出 DOS 命令行

- cls 清屏

- echo  将一段内容写入某个类型的文件中(并新建)：`echo 文件中的内容>文件的名称.文件的类型`

删除指定目录下的所有文件：`del 文件名称` //必须再指定目录的上一级

常用快捷键

- ←→: 移动光标
- ↑ ↓:调阅历史操作指令
- Delete 和 Backspace:删除字符

##### 2. 计算机编程语言概述、

语言：沟通交流的一种方式。(例如人类的语言、鸟语等)

计算机语言：人与计算机交流的方式

如果人要与计算机交流，那么就要学习计算机语言。

> 理解：我们想要让计算机作出某些操作，必须用计算机能够理解的方式，对其作出指令。

**语言的发展历程**

- 第一代语言：机器语言

  机器语言。指令以二进制形式存在。

- 第二代语言：汇编语言

  汇编语言。使用助记符来表示一条汇编指令。

- 第三代语言：高级语言

  - 按照执行方式可以划分为：编译型语言和解释型语言。
  - 按照语言特性又可以划分为：面向对象和面向过程的语言。
  - 按照数据类型的特性又可以分为：弱类型语言和强类型语言。

> - C、Pascal、Fortran 面向过程
> - C++ 面向过程\面向对象
> - Java 跨平台的纯面向对象语言
> - .NET 跨语言的平台
> - Python、Scala 

##### 3. Java 语言概述

- 是 SUN（Stanford University Network,斯坦福网络公司）1995 年推出的一门高级编程语言。

- Java 是一种面向 Internet 的编程语言。Java 在刚开始时，富有吸引力，那是因为它能够在 Web 浏览器中运行。这些 Java 程序被称为 applet，（内嵌在 HTML 代码中），使用图形化界面与 Web 用户产生交互(已过时，还有 Bug)。

- 随着Java 技术在 web 方面的不断成熟，已经成为 Web 应用程序的首选开发语言。

  注：后端开发：Java、PHP、Python、Go、Node.js

**发展简史**

> - 1991 年 Green 项目，开发语言命名为 Oak (橡树)
> - 1996 ，发布 JDK 1.0
> - 1999,java 分成J2SE,J2EE和 J2ME,JSP/Servlet 技术诞生
> - **2004 年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性更名为 JDK 5.0**
> - 2005 年，改名：J2SE >>JavaSE,J2EE>>JavaEE,J2ME>>JavaME
> - 2009 年，Oracle 收购 SUN。
> - **2014 年：发布 JDK 8.0，是继 JDK 5.0 以来变化最大的版本。**
> - 2018年3月，发布 Java 10.0,以后的版本以时间为版本号 18.3。

**Java 技术体系平台**

|  Standard Edition  | SE 标准版 | 用于桌面级应用或简单服务器应用 Java 平台，提供了完整的Java核 心API，，此版本以前称为 J2SE |
| :----------------: | :-------: | :----------------------------------------------------------: |
| Enterprise Edition | EE 企业版 | 用于复杂服务器应用的 Java 平台，该技术体系中包含的技术如 :Servlet 、Jsp；此版本以前称为 J2EE |
|   Mciro Edition    | 小型版ME  | 用于手机或其他小型设备 Java 平台,此版本以前称为 J2ME 对Java API有所精简，并加 入了针对移动终端的支持 |



**JAVA EE (Java Enterprise Edition) 企业版本**

是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet 、 Jsp 等，主要针对于 Web 应用程序开发。

**JAVA ME(Java Micro Edition) 小型版**

支持 Java 程序运行在移动终端（手机、 PDA ）上的平台，对 Java API 有所精简，并加入了针对移动终端的支持，此版本以前称为 J2ME

**Java Card**

支持一些 Java 小程序（ Applets ）运行在小内存设备（如智能卡）上的平台

注：linux (推荐)选择 tar.gz 版本。

Java 在各领域的应用：

- 企业级应用: 复杂的大企业的软件系统，各种类型网站。：主要指复杂的大企业的软件系统、各种类型的网站。 Java 的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。
- Android 平台应用
- 大数据平台开发：：各类框架有 Hadoop spark storm flink 等，就这类技术生态圈来讲，还有各种中间件如 flume kafka sqoop 等等 ，这些框架以及工具大多数是用 Java 编写而成，但提供诸如 Java scala Python R 等各种语言 API 供编程。
- 移动应用领域

> Java 之父 James Gosling。
>
> **发现 C  缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。**
>
> Java 从 C 语言和 C++ 语言继承了许多结构，甚至可以看作为是 类 C 语言发展和衍生的产物。Java 增加了垃圾回收器，抛弃了 C 语言中容易引起错误的指针。
>
> JDK1.5 又引入了泛型编程（Generic Programming）、类型安全的枚举、不定长参数和自动装/拆箱
>
> 跨平台（一次编译，处处运行[没有兼容问题]）
>
> 注：Java 是严格区分大小写的‘

Java 语言的主要特性：

简单易学、面向对象、分布式、健壮的、安全的、体系结构中立、解释型、性能略高、原生支持多线程

- 易学：语法与 C 语言、C++ 很接近
- 面向对象：Java 语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements ）。
- 分布式：Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（ java net ），它提供了用于网络应用编程的类库，包括 URL 、 URLConnection 、 Socket 、 ServerSocket 等。 Java 的 RMI （远程方法激活）机制也是开发分布式应用的重要手段。
- 健壮：Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。
- 安全：Java 通常被用在网络环境中，为此， Java 提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类 ClassLoader ），如分配不同的名字空间以防替代本地的同名类、字节代码检查。
- 体系结构中立：Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个Java 平台的任何系统中运行。
- 解释型：Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统的解释器中运行。

##### 4. Java环境的搭建

| JVM  | Java 虚拟机     | Java Virtual Machine | 在不同的系统中，有不同的虚拟机。而 Java 源程序在 JVM 中运行。 |
| ---- | --------------- | -------------------- | ------------------------------------------------------------ |
| JRE  | Java  运行环境  | Java Run  Envriment  | 包含 JVM(可以运行的不同平台) 和 核心类库(能让 Java 源程序运行) |
| JDK  | Java 开发工具包 | Java Dvelpment kit   | 包含 JRE 和 Java 的开发工具。                                |

> - JDK = JRE + 开发工具集
> - JRE = JVM + Java SE标准类库

Java 程序还会出现内存泄漏和内存溢出吗？会

**JDK下载地址**：

- http:[www.oracle.com](www.oracle.com)
- java.sun.com

**安装JDK：**

- 傻瓜式安装： 下一步即可
- 建议：安装路径中不要有中文或空格等特殊字符
- 如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）
- 当提示安装 JRE 时，正常在 JDK 安装时已经装过了，但是为了后续使用Eclipse等开发工具不报错，建议也根据提示安装JRE。

**JDK 下的目录**

Bin     	    开发工具

Db 	 DB数据库，供学习测试使用，开发不建议使用。

Include        用于本地代码的头文件。

Src.zip        JDK 类库源代码文件

Lib             相关类库

查看版本号：再任意路径输入 `Java -version`

检查环境变量：`echo %PATH%`

***配置环境变量\***

**配置方法**

path: windows 系统执行命令时所需要搜寻的路径

此电脑 》属性》高级系统设置》环境变量》新建环境变量

注意变量名必须是 path ，值则是路径。

变量名：JAVA_HOME

变量值：JDK 中 bin 所在的上一级目录。例如：D:\jdk-11.0.2_windows-x64_bin\jdk-11.0.2

变量名：path

变量值：%JAVA_HOME%\bin     

注：

1. 点击原有的 PATH 选择**编辑**然后**新建**，将路径粘贴之后点击确认。
2. 用户环境变量仅对当前用户有效。而系统环境变量对所有用户有效
3. 变量名不区分大小写，因此在创建环境变量的时候不要直接新建变量名为 path ,否则会对原有重名的环境变量进行覆盖。
4. 百分号要用英文输入
5. %JAVA_HOME%，意为获取变量名为 JAVA_HOME 的变量值
6. **在老旧的系统中，编辑 path 环境变量，需用 “ ; ”和其他值分隔开。**

建议把 Java 开发工具的变量(即 JDK 所在 path 中)移动到最前面（避免遇到有些 Java 开发工具不能使用的情况。）。

**CLASSPATH** 

- 如果没有配置 CLASSPATH 会自动到当前目录下寻找指定的名称**编译后的字节码**.
- 如果配置了 CLASSPATH，无论在哪个目录下，都会去寻找配置的 CLASSPATH 目录下寻找指定名称的**字节码**。

为什么要配置 Java 环境变量？

因为我们想要在任何目录路径下都可以执行 bin 目录下的任意指令

> 配置成功：
>
> 打开DOS命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。

编程语言排行榜：[www.tiobe.com](www.tiobe.com)

##### 5. 开发体验 —— HelloWorld

**编写运行程序步骤**：

①  将 java 源代码编写到扩展名为 `.java` 的文件中。

②  通过 `javac 源文件名.java`命令对该 java 源文件进行编译(编译成 JVM 能够识别的字节码)，并生成扩展名为 `.class` 的文件。

③  通过 java 命令对编译后的文件进行运行。（JVM执行编译的字节码）  格式：`java 类名`

注：使用 javac 编译时需要带后缀名，使用 java 执行字节码文件时，不要需要带后缀名

   Java 文件格式

```
class hello{
    public static void main(String[] args){
        //源程序
    }
}
```

**注意事项：**

① 编译后字节码文件的名称和 class 名称一样。（这里的 class 是指在源代码中的声明的 Java 类的名称 ）

② 一个 Java 源文件中可以声明多个 class,如果 **class 前添加了一个 public，那么该 java 源文件名必须跟 class 的名称保持一致。**

③ 注意大小写。

> 除了我们使用 javac 对文件进行编译时，文件名不区分大小写，其他时刻都区分大小写。

④ main 方法作为程序的入口,格式固定的。

⑤ 输出语句：

```
System.out.println();//先输出后换行
System.out.print();//只输出数据
```

⑥ Java 源代码当中的每一条执行语句都以 ";" 结束。

⑦ 编译的过程： 编译之后会生成一个或多个字节码文件，字节码文件的文件名与 Java 的类名一致(在一个源文件中声明几个类，就会编译成几个字节码文件)。

其中内部类的的文件名为 `外部类文件名$内部类文件名.java`

⑧ java 命令格式：`java 字节码文件名`

注意这里的文件名不需要带后缀名

> 扩展：
>
> 为什么会有程序的入口？
>
> 因为在底层所有的指令和数据都是以二进制的形式存在的，CPU 必须要判断哪些是指令，哪些是数据。而程序的入口确定了 CS:IP (也就是程序执行的指针)。然后程序就可执行下去了。

**常见问题及解决办法**：

第一种：找不到文件

- 源文件名不存在或者写错
- 当前路径错误
- 后缀名隐藏问题

第二种：找不到或无法加载主类

- 类文件名写错，尤其是文件名和类名不一致
- 类文件不在当前路径下，或者不在 classpath 指定路径下

第三种：类`****`是公共的，应命名为 `****`.java …

- **声明为public 的类应与文件名一致，否则编译失败。**

第四种：编译失败，注意错误出现的行数，再到源代码中指定位置改错

注：这里的类文件指的是编译后的字节码文件

##### 7. 注释（Comment）

1\. java规范的三种注释方式：

对程序进行解释说明的文字。

- 单行注释：`//`注释内容
- 多行注释：`/*注释内容*/`
- 文档注释格式：

```
/**
  *注释内容
  *@param args
  */
```

它可以把注释的内容生成文档。

2\. 单行注释和多行注释的作用：

① 对所写的程序进行解释说明，提高了代码的阅读性；方便自己，方便别人

② 调试所写的代码

可以用注释来排错。可以将感觉错误的代码片段注释掉

3\. 特点

编译器并不会把注释内容编译为字节码，也就不会被 JVM 执行

单行注释和多行注释，注释了的内容不参与编译。换句话说，编译以后生成的 .class 结尾的字节码文件中不包含注释掉的信息

4\. 文档注释的使用 **javadoc**

文档注释的内容可以被 JDK 提供的工具 javadoc 解析，生成一套以网页形式存在的该程序的说明文档。

作用：将文档注释提取为 HTML 页面

格式：`javadoc -d HTML要存放的文件名(会自动创建) -author -version 要提取的 java 源程序文件`

```
\**
  *@author 指定 Java 程序的作者
  *@version 指定源文件的 版本
  */
```

例子：`javadoc -d myHello -author -version Hello.java`

5\. 多行注释里面不允许嵌套使用

##### 8. Java 的 API 文档

下载地址: 和 Java JDK 在同一个页面

- API (Application Programming Interface,应用程序编程接口)，是 Java 提供的基本编程接口。
- Java 语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的 API 文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。

##### 9. Java 常用开发工具（Integgrated Development Enviroment）

文本编辑工具：

- notepad++
- notepad
- editplus
- TextPad
- UltraEdit

集成开发环境(IDE,Integrated Development Enviroment)

- JBuilder
- NetBeans
- eclipse        IBM
- myeclipse 分为收费版和付费版
- IDEA  分为社区版、旗舰版（收费）、教育版

##### 10. 良好的编程风格

正确的注释和注释风格：

- 使用文档注释来注释整个类或方法。
- 如果注释变量或方法中某一个步骤，使用单行或多行注释。

正确的使用缩进和空白：

- 使用 Tab 实现缩进
- 运算符左右两边都习惯性各加一个空格

**代码块的风格**：

推荐：行尾风格：

```
public class Test{
    public static void main(String[] args){
    System.out.println("Block Style");    
    }
}
```

次方风格：

```
public class Test
{
    public static void main(String[] args)
    {
    System.out.println("Block Style");    
    }
}
```

注：

- JDK 的下载地址：[www.oracle.com](www.oracle.com)
- Eclipse 的下载地址：[www.eclipse.org](www.eclipse.org)

### 第二章 基本语法 变量与运算符

##### 1. 关键字和保留字

- 关键字：在编程语言中有一些事先定义好的、有着特殊含义和用途的字符串 (单词)。

  特点：关键字中所有字母小写

- 保留字：和关键字一样都是事先定义好的，只是现在暂时没有特殊的用途，但说不定以后某天就会被赋予意义和被使用到，因此被保留下来的单词。

  goto const

**关键字**：

- 用于定义数据类型：

|  class  | interface | enum  |  byte  | short |
| :-----: | :-------: | :---: | :----: | :---: |
|   int   |   long    | float | double | char  |
| boolean |   void    |       |        |       |

- 用于定义流程控制的关键字：

|   if   | else | switch | case  | default  |
| :----: | :--: | :----: | :---: | :------: |
| while  |  do  |  for   | break | continue |
| return |      |        |       |          |

- 用于定义访问修饰符权限的关键字：`private,protected,public`
- 用于定义类，函数，变量修饰符的关键字：`abstract,final static,synchronized`
- 用于定义类和类之间关系的关键字：`extends implements`
- 用于定义建立实例及引用实例，判断实例的关键字：`new,this,super,instancedof`
- 用于异常处理的关键字:`try,catch,finally,throw,throws`
- 用于包的关键字：`package,import`
- 其它修饰符关键字：`native,strictfp,translent,volatile,assert`
- 用于定义数据类型值字面值：`true,false,null`

**保留字**（reversed words）

```
byValue, cast, const,false, future, generic, gotoinner, null，operator, outer, rest, true, var,goto
```

##### 2. 标识符（Identifier）

1\. 标识符的使用

- 在 Java 程序中，我们对各种变量、方法和类、形参等命名时使用的字符序列。
- 程序中我们自己起名字的地方叫做 **标识符**。

2\. 标识符命名规则：

① 可以包含 26 个英文字母，0~9，_，$

② 不能以数字开头，不可以使用关键字和保留字，但可以包含关键字和保留字 

③严格区分大小写，长度无限制 

④ 标识符中不能含有空格

个人建议：类名中尽量不要含有 $ 符，因为一个源文件中如果有多个类，那么那个编译之后的文件名 classname$classname (尽管通常一个源文件中只有一个类)。

3\. 标识符命名规范

- 包名：所有字母都小写 xxxyyyzzz
- 类名，接口名：所有单词首字母大写 XxxYyyZzz
- 方法名，变量名：多单词组成时，第一个单词首字母小写，从第二个单词开始每个单词首字母大写xxxYyyZzz
- 常量名：所有字母都大写，多单词组成时，每个单词之间用下划线连接。XXX_YYY_ZZZ

4\. 注意：

- 起名字时，为了提高阅读性，要尽量有意义，“见名知意”。
- Java 采用 unicode 字符集，因此可以使用中文声明标识符，但不建议使用。

##### 3. 变量

**1.** 定义：

变量是在内存中开辟的一块存储空间，该存储空间中的数据可以在类型规定的范围内不断变化。变量是程序中最基本的存储单元。

**作用**：用于内存中存储

2\. 注意：

1. 变量必须先声明，后调用
2. 通过使用变量名来访问和修改这块内存空间中的数据
3. 变量只有在其作用域内有效: 其定义所在的一对 {} 内。
4. 在同一作用域内或嵌套的代码中不能使用同名的变量。
5. 变量使用之前一定要初始化 (赋值)。

3\. 变量的声明及赋值

- 声明变量：`数据类型 变量名称`
- 变量赋值：`变量名称 = 值;`
- 声明和赋值变量: `数据类型 变量名称 = 变量值;`
- 数据类型作用：规定了，存储空间存放什么类型的数据（相应的数据存放在相应类型的空间中

4\. 变量按照位置可以分以下几类：

对于每一种数据都定义了明确的具体数据类型（强类型语言），并且为规定了每一种数据类型所占用的内存空间。

- **成员变量**(属性、全局变量)：内部结构外，类体内。直接在类内声明的变量。

  - 实例变量（不以 static 修饰）
  - 类变量( 以 static 修饰)

  > 这里类的内部结构指：方法、构造器、内部类、代码块。构造器是一种比较特殊的方法，在创建对象时调用。

- **局部变量**：在方法内、代码块内，构造器内、内部类内，形参中

  - 方法局部变量（在方法中定义的变量）
  - 代码块局部变量 （在代码块中定义的变量）
  - 形参（在方法，构造器传入参数时定义的变量）

5\. 成员变量和局部变量的异同点：

|                | 相同点                                                       | 不同点                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 成员变量(属性) | 1. 都有作用域（生命周期） 2. 先声明，后使用。 3. 变量定义的格式：`数据类型 变量名 = 变量值` | 定义位置：直接定义在类中可以在声明时，指明权限，使用权限修饰符。有默认初始化值，同一维数组内存位置：加载在堆空间中 |
| 局部变量       | 定义位置：定义在方法中，方法形参，代码块内，内部构造器内、构造器形参的变量没有初始化值，在使用之前要显式赋值（初始化）内存位置加载在栈空间中 |                                                              |

##### 4\. 数据类型分类

- 基本数据类型：
  - 数值型
    - 整数类型（byte,short,int,long）
    - 浮点类型　(float,double)
  - 字符型 (char)
  - 布尔型（boolean）
- 引用数据类型：
  - 类 （class）
  
  - 接口 （interface）
  
  - 数组 （Array[]）
  

字符串 （String）也是一种类

##### 5\. 基本数据类型：

Java 的各数据类型都有固定的表示范围和字段长度，不受 OS 的影响，以保证 Java 程序的可移植性。 1Byte = 8 bit

###### 一、整数类型  

| 类型  | 占用存储空间 |               表示范围                |
| :---: | :----------: | :-----------------------------------: |
| byte  |    1 Byte    |              - 128 ~ 127              |
| short |    2 Byte    | $-2^{15} ～2^{15}-1 $  (-32768~32767) |
|  int  |    4 Byte    |    $-2^{31}～2^{31}-1$ (约 21 亿)     |
| long  |    8 Byte    |          $-2^{63}～2^{63}-1$          |

###### 二、浮点类

- 浮点型常量有两种表示形式： 
- 十进制数形式：如：`5.12 512.0f .512` (必须有小数点） 
- 科学计数法形式:如：`5.12e2 = 5.12*10^2,512E2 = 512 * 10 ^ 2, 100E-2 = 100 * 10^{-2}`   
- float：单精度，尾数可以精确到 7 位有效数字。很多情况下，精度很难满足需求。 
- double:双精度，精度是 float 的两倍。通常采用此类型

|  类型  | 存储空间 |        表示范围        |
| :----: | :------: | :--------------------: |
| float  |  4 字节  |  -3.403E38 ~ 3.403E37  |
| double |  8 字节  | -1.798E308 ~ 1.798E308 |

Tips:

① 整数默认是 int 类型，浮点数默认是 double 类型

② long 长型整数后用 L 或 l 标记 ,单精度浮点数用 F 或 f 标记。(建议使用大写字母做标记)

③通常， 定义整型变量，使用  int 类型

通常，定义浮点型变量时，使用 double 型。

③ float 存储的数据的范围比 long 还大

###### 三、字符型 char (1字符=2字节)

- char 类型数据用来表示通常意义上的 “字符”。(两字节)
- Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。其中中文占 0x9fa5 - 0x4e00，共 20901 个字符。汉字常用 7000 余个字符。
- char 类型可以进行运算，因为它有对应的 Unicode 码。
- 字符型变量的三种表现形式：
  - **用单引号括起来的单个字符**。例如: 'u'
  
    定义char型变量，通常使用一对'',内部只能写一个字符
  
  - 允许使用转义字符\来将其后的字符转变为特殊字符型常量。例如：\n 表示换行符
  
  - 直接使用 Unicode 值来表示字符型常量。 '\u0008' 

注：`char c1 = 数字;`（数字对应 ASCLL 表中对应的字符）

转义字符：

特殊字符的转义序列：

| 转义序列 | 名称 | Unicode值 | 转义序列 | 名称   | Unicode 值                                           |
| -------- | ---- | --------- | -------- | ------ | ---------------------------------------------------- |
| \b       | 退格 | \u0008    | "        | 双引号 | \u0022                                               |
| \t       | 制表 | \u0009    | \        | 单引号 | \u0027                                               |
| \n       | 换行 | \u000a    | \ \      | 反斜杠 | \u005e                                               |
| \r       | 回车 | \u000d    |          |        | 注：转义序列 \u 可以出现在加引号的字符或字符串之中。 |

**Unciode 编码**

一种标准，将世界上所有的常用符号都纳入其中。每一个符号都给予一个独一 无二的编码，使用 Unicode 没有乱码的问题。

因为 unicode 字符集占用**两个字节** ，因此取值范围：`\u0000 ~ \uffff`

###### 四、布尔类型 

规范

① **不可以使用 0 或非0 的整数替代 false 和 true**，这点和 C 语言不同

② 只允许取值 true 和 false，无 null

③ 在打印 boolean 值时，并不会打印 0或1，而是 true 或 flase;

④  常常在条件判断、循环结构中使用

> Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达所操作的 boolean 值，在编译之后都使用 Java虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。———《java虚拟机规范 8 版》

```
boolean bool  =  true;
System.out.println(bool);//true
System.out.println("hello"+bool);//hellotrue
boolean bool1 =  false;
System.out.println(bool1);//false
```

##### 6. 基本数据类型之间的转换

前提：7 种基本数据类型变量间的转换，不包括 boolean 类型。

实心箭头表示无信息损失转换，表示有可能精度损失的转换

###### 1. 自动类型提升：

在做运算时会自动把容量小的数据类型转换为容量大的数据类型（结构就是容量大的数据类型。）

基本数据类型之间的运算规则：

前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。

- 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。 
- byte,short,char 之间不会相互转换，他们三者在计算时默认转换为 int 类型。 
- **boolean类型不能与其它数据类型运算。** 
- 任一基本数据类型的值和字符串 (String) 进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。

注：

这里的容量大小指的是，表示数的范围的大和小。比如：float 容量要大于 long 的容量

JVM 识别的最小的整型数值类型为 int。(当运算的两个数据都小于 int 时，没有使用强制数据类型转换，jvm 会自动将结果转换为 int 类型。）

```
byte num = 34;
byte num1 = 45;
num + num1;//结果为 int 类型
```

###### 2\. 强制类型转换：

- 需要使用强转符：()

- () **注意可能造成精度损失或数据溢出。**

- 将容量大的数据类型转换为容量小的数据类型，使用时需要加上强制类型转换符：

- 强制类型转换只对最近的变量有效

- 字符串不能直接转换为基本数据类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型，举例：

  ```
  String a = "43";
  int i = Integer.parseInt(a);
  ```

- 格式：`变量1 = (数据类型)变量2`。

- boolean 类型不可以转换为其它的数据类型

注：数据溢出：就是声明变量的存储空间，存放不了那么大数据。（数据值超出声明变量类型的存储空间）

##### 7\. 引用 String 类型

1. String 属于引用数据类型
2. 声明 String 类型变量时，使用一对双引号 （“”）。
3. String 数据类型变量和其他八种基本数据类型变量做运算，那么，运算只能时连接运算。运算的结果依然是 String 类型。

***引用数据类型的变量只可以存放两类值： null  或 地址值\***

##### 8\. 进制

对于整数，有四种表示形式：

- 二进制(binary): 0,1 。以 0b 或 0B 开头
- 十进制(decimal):0~9
- 八进制(octal)：0~7。以 0 开头
- 十六进制(hex)：`0~9 及 A~F` 。以 0x 或 0X 开头。这里的 A~F 不区分大小写

**原码、补码、反码**

原码：直接将一个整数转换为二进制数，最高位为符号位。符号位 0 表示正数，1 表示负数。

反码：负数二进制数对除符号位的其他位进行取反操作。

补码：负数的补码：为其反码加 1

正数，原码补码，反码都相同。

计算机底层都已补码的形式来存储数据。

**将十进制转换为二进制：**

 如果一个数很大就采用； ”除 2 取余 的逆“

##### 9. 运算符

###### 1\. 算术运算符：

```
+，-，*，/，%，++，--
```

注意：

1. 除法的除数不能为 0，在运算时会有异常发生。

2. 整数之间做除法时，只保留整数部分而舍弃小数部分。

3. 取模：取模结果符号(正负号)取决于被取模数（由前面的那个数决定），模数符号忽略。

   取模原理：`a%b`

```
5 % -2 = 1;//取模结果符号(正负号)由前面的那个数决定（被取模数)
10 % 3 = 1;
-10 % 3 = -1;
-10 % -3 = -1;

100.0 \ 0 = infinty;
-100.0 \ 0 = -infinty;
0.0 \ 0.0 = NaN;
```

一个除法的例子：

```
int num1 = 12；
int num2 = 5;
int res = num1 / num2; //2
double res = num1 / num2;//2.0

double res = num1 / (num2 + 0.0);//2.4 相当于将 num2 转换为 double 类型
double res = (double)num1 / num2;//2.4 先将 num1 强制转换为 doule 类型然后进行运算
double res = (double)(num1 / num2);//2.0 将运算的结果禁止强制转换
```

++ ，-- 用法：必须要使用在变量的前后。

作用：表示当前操作的变量累加 1 或累减 1

"++" 和 "--"在变量前后的区别：

1. 如果不参与运算，没有区别。
2. 如果参与了运算:
   - 符号在变量前，累加(或累减)的结果参与本次运算。也就是使用累加(或累减)之后的值参与运算。（先自增，后运算）
   - 符号在变量后，累加的结果的不参与本次的运算，也就是使用变量的累加之前的值 参与运算。（先运算，后自增）

注：自增 1或自减 1 不会改变本身变量的数据类型。

```java
short s1 = 10;
		//s1 = s1 + 1;//编译失败,这里会自动类型提升为 int 类型
		//s1 = (short)(s1 + 1);//正确的
		s1++;//自增1不会改变本身变量的数据类型
		System.out.println(s1);
```

###### 2\. 赋值运算符：

- 当 “=” 两侧数据类型不一致时，可以使用自动类型提升或强制类型提升进行处理
- 支持连续赋值。
- 扩展赋值运算符：+=，-=，*=，/=，%=  

```java
int a = 1; a = a + 1;//其它的一次类推
```

结论：

① 不会改变变量本身的数据类型。

```java
short s1 = 10;
//s1 = s1 + 2;//编译失败
s1 += 2;//结论：不会改变变量本身的数据类型
System.out.println(s1);

//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)
//方式一：num = num + 2;
//方式二：num += 2; (推荐)

//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)
//方式一：num = num + 1;
//方式二：num += 1; 
//方式三：num++; (推荐)

//练习1
		int i = 1;
		i *= 0.1; // int 与 doule 类型计算会自动提升 double 类型，但是赋值运算符并不会改变原有的数据类型，最后还是会转换为 int 类型因此 = 1
		// i = i * 0.1;
		System.out.println(i);//0
		i++;
		System.out.println(i);//1

//练习3
		int n1 = 10;
		n1 += (n1++) + (++n1);//n1 = n1 + (n1++) + (++n1);
		System.out.println(n1);//32
```

###### 3\. 比较运算符（关系运算符）：

== !=  >  < <=  >=  instanceof 

1. 运算的结果是一个 Boolean 值
2. 注意区分 == 和 = 
3. 注意 &&、&、|、||、的执行顺序与规则

###### 4\. 逻辑运算符

- 与 &

格式：逻辑表达式 1  & 逻辑表达式 2

结果：一 false 即 false ，两 true 为 true

使用时的时候，无论左边是真还是假，都会执行右面的表达式。（无论什么结果，两边都会执行）

- 或 |

格式：逻辑表达式1  | 逻辑表达式2

结果：一 true 即 true ,两 false 为 false

- 非！   对一个 Boolean 类型值取反操作

格式： ！布尔类型值

- 异或：逻辑表达式1  \^  逻辑表达式2

结果：不等是 true， 相等是 false ；相同时为 0（false),不同为 1 true

- 短路与 &&

格式：逻辑表达式 1 && 逻辑表达式 2

一 false 即 false ,两个都为 true 才为 true。

如果左边为 false 就不会执行右边的表达式。

- 短路或||

格式：表达式1 || 表达式2

结果： 一 true 即 true  两个结果都为 false 才为 false

**& 与 && 的区别**：

相同点：

① 运算结果相同

② 当符号左边是 true 时，两者都会执行符号右边的运算。

不同点：

① 当符号右边是 false 时，&& 不会执行符号右边的运算，而 & 会继续执行符号右边的运算。

开发中，推荐使用&&

**或 | 与 短路或 ||的区别**：

相同点：

① 运算结果相同

② 当符号左边为 false 时，两者都会执行然后右边的运算

不同点：

1. 当符号右边为 true 时，|| 不会执行符号右边的运算，而 | 会继续执行符号右边的运算。

开发中，推荐使用 ||

注：

1. 逻辑运算符操作的都是 boolean 类型的变量。
2. 运算的结果也是 boolean 类型
3. 开发中推荐使用 “短路与 &&” 和 “短路或 ||”

###### 5\. 位运算符：

位运算符是指对二进制位从低位到高位对齐后进行运算

| <<   | 左移       | 3 << 2 = 12   ($3\cdot 4=3\cdot 2 \cdot 2$) | 被移除的位丢弃，空位补零(符号位不变)                         |
| ---- | ---------- | ------------------------------------------- | ------------------------------------------------------------ |
| >>   | 右移       | 3 >> 1 = 1     （${3\over 2} = 1$）         | 被移位二进制最高位是 0，右移时，空缺位补 0。 最高位是 1，右移时，空缺位补 1 |
| >>>  | 无符号右移 |                                             | 无论最高位是 0 还是 1，空缺位都是补 0                        |
| &    | 与运算     | 6 & 3 = 2                                   | 相同位的两个数，只有都是 1 时结果是 1，否则为零。(两 1 为 1，否则为 0) |
| \|   | 或运算     | 6 \| 3 = 7                                  | （一 1 为 1 ，同 0 为 0）                                    |
| ^    | 异或运算   | 6 ^ 3 = 5                                   | （相同为 1，不同为 0）                                       |
| ~    | 取反：     | ~ 6 =  - 7                                  | 按二进制各位取反                                             |

 总结：正数取反 ~n=-(n+1), ~-n=n-1 

结论：

① <<: 在一定范围内，每向左移一位就扩大 2 倍。   >>: 反之，在一定范围内，每向右移一位就缩小 2 倍。

② 位运算操作的都是整型的数据。

```java
		//练习：交换两个变量的值
		int num1 = 10;
		int num2 = 20;
		System.out.println("num1 = " + num1 + ",num2 = " + num2);

		//方式一：定义临时变量的方式
		//推荐的方式
		int temp = num1;
		num1 = num2;
		num2 = temp;

		//方式二：好处：不用定义临时变量  
		//弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型
		//num1 = num1 + num2;
		//num2 = num1 - num2;
		//num1 = num1 - num2;

		//方式三：使用位运算符
		//有局限性：只能适用于数值类型
		//num1 = num1 ^ num2;
		//num2 = num1 ^ num2;
		//num1 = num1 ^ num2;

		System.out.println("num1 = " + num1 + ",num2 = " + num2);
```



###### 6\. 三元运算符：

1\. 语法格式：`条件表达式 ？表达式 1 : 表达式 2;`

2\. 说明

① 条件表达式的结果为 Boolean 类型
② 根据条件表达式真或假，决定执行表达式1，还是表达式2.

如果条件表达式的值为 true， 则执行表达式1，返回表达式 1 的值，

条件表达式的值 false，则执行表达式2，返回表达式 2 的值。

③ 表达式 1 与表达式 2 的值为同种类型 (可以为*接受变量*的类型，可以自动类型提升）

④ 三元运算符可以嵌套使用

###### 7\. 三元运算符与 if - else 的区别：

① 三元运算符可以简化为 if - else，if-else 却不一定能简化为三元运算符

② 三元运算符要求必须返回一个结果

③ if 后的代码块可以有多个语句

如果程序既可以用三元运算符，也可以用 if…else，那么优先使用三元运算符。原因：简洁，效率更高。

```java
//*****************************
		//获取三个数的最大值
		int n1 = 12;
		int n2 = 30;
		int n3 = -43;
		
		int max1 = (n1 > n2)? n1 : n2;
		int max2 = (max1 > n3)? max1 : n3;
		System.out.println("三个数中的最大值为：" + max2);

		//不建议
		//int max3 = (((n1 > n2)? n1 : n2) > n3)? ((n1 > n2)? n1 : n2) : n3;
		System.out.println("三个数中的最大值为：" + max3);
		
		//尝试改写成 if-else 结构
```

###### 8\. 运算符的优先级：

- 运算符的优先级，所谓优先级就是表达式中的运算顺序。如：数学中的先算乘除后算加减
- 只有单目运算符、三元运算符、赋值运算符是从右向左运算。（单目运算符就是操作一个数或变量的运算符。如：累加、累减、取反等）

```
() {}；，.
++，--.~,!
*,/,%
+,-
<< >> >>> 
< <= > >= instanceof
== != //条件表达式运算符
&
^
|
&&
||
? ：//逻辑运算符
>>>=.>>=.<<=,^=,|=,&=.%=./=,*=.-=.+=.=//赋值运算符
```

##### 6. 字符集

**ASCII**

ASCII：是上个世纪 60 年代，美国制定的一套字符编码，对英语字符和二进制位之间的对应(映射)关系，做了同一规定。这被称为 ASCII 码。ASCII 一共规定了 128 个字符的编码。只占用了一个字符的后面 7 位，最前面的 1 位统一规定为 0.

缺点：

- 不能表示所有的字符。

**乱码：**

世界上存在着多种编码方式，同一个二进制数字，根据编码不同，可以被解释成不同的字符。因此打开一个文本文件，就必须知道它的编码方式。用了不正确的编码格式打开，就会出现乱码。

**Unicode**

一种编码，世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 就没有乱码的情况。

缺点：

- Unicode 之规定了符号的二进制代码，却没有规定二进制代码如何存储。计算机无法区分是三个字节表示一个符号，还是三个字节表示三个符号。
- 另外，我们知道英文字符只用一个字节表示就足够，而 Unicode 统一归档，每个字符用三个或四个字节表示，那么每个英文字母都必然两到三个字节是 0 ，极大浪费存储空间。

**UTF-8**

- UTF-8 是互联网上使用最广的一种 Unicode 的实现方式。
- UTF-8 是一种的变长编码方式。 它可以使用 1~6 个字节表示一个字符，根据符号的不同而变化字节长度。

*UTF-8 的编码规则：*

- 对于单字节的 UTF-8 编码，该字节的最高位为 0，其余七位用来对字符及进行编码(UTF-8)
- 对于多个字节的 UTF-8 编码，如果编码包含 n 个字节。那么第一个字节的前 n 位为 1，第一个字节的第 n + 1 位为 0，该字节的剩余各位用来对字节进行编码

### 第三章 程序流程控制

##### 1\. 流程控制概述：

1\. 定义

流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块

2\. 三种基本流程结构：

- 顺序结构：从上到下逐行执行代码，中间没有任何判断和跳转。

- 选择结构：根据条件选择性的执行某段代码（if - else、switch - case）

- 循环结构：根据条件，重复性的执行某段代码

  有 (do - while、while、for)

  JDK 1.5 及以后提供了 foreach 循环，方便遍历集合、数组元素。

##### 2. 选择结构

**if - else**

```
//第一种格式：
if(条件表达式){
    语句1;
}//不符合条件直接跳出, 符合条件执行语句1

//第二种格式：
if(条件表达式){
    语句1
}else{
    语句2
}
//符合条件执行语句 1，不符合条件执行语句 2 （二选一）

//第三种格式:
if(条件表达式){
    语句 1
}else(条件表达式){
    语句 2
}
…
else{
    语句 n
}
//根据条件表达式选择执行语句(多选一)
```

注意：

1. 如果if-else结构中的语句块执行语句只有一行时，对应的一对 `{}` 可以省略的。但是，不建议大家省略。
2. else 结构是可选的。*如果不使用] `{}`，else 会与最近的 if 结构相匹配*（不建议省略大括号）。
3. 条件表达式必须是布尔表达式(关系表达式或逻辑表达式)；即结果必须是布尔值
4. 针对于条件表达式：
   - 如果多个条件表达式之间是 "互斥" 关系，条件表达式的顺序无所谓。
   - 如果多个条件表达式有交集的关系，需要根据实际情况，考虑清楚那个应该声明在上面
   - 如果多个条件表达式有包含的关系，通常需要将范围小的声明范围大的上面。否则范围小的就没有机会执行了。
5. `if-else` 结构是可以根据需要进行嵌套

**switch - case ()**

```
switch(表达式[可以放字符]){
    case 常量A :{
        执行语句 1…n;
    }break；
    case 常量B :{
        执行语句；
    }break;
    ......
    default：执行语句（如果前面没有一个满足条件：就会执行此语句）
    break;
}
```

注意：

1. case 值不能相同。 

2. case 之后只能声明常量，不能声明范围

3. 根据 switch 表达式的值，依次匹配各个 case 种种的常量，一旦匹配成功，则进入相应 case 结构种，调用其执行语句，一旦执行所有之心该语句之后，则仍然继续向下执行其它 case 结构中的执行语句。直到遇到 break 或 swtich -case 末尾结束为止。

4. switch 结构种的表达是，只能是如下的 6 种数据类型之一：byte、short、char、int、枚举类型（JDK 5.0 新增）、String(JDk 7.0 新增)

5. break 关键字是可选的。break 可以用在 switch - case 中使用，表示一旦执行到此关键字就跳出 switch - case 结构

6. default结构是可选的，而且位置是灵活的。相当于if-else结构中的else。如果传进来的值，与 case 值都不匹配就执行 defualt 种的执行语句（位置:一般在所有 case 语句之后）；

   default 可以放到最上面，也可以放在相邻的case 之间(位置灵活)，要在后面加上 break，如果没有加上break，它也会自动向下执行。

7. 花括号代码块也可以省略。因为 switch-case 结构时匹配之后，向下漏着执行。遇到 break 或末尾停止。因此不太需要花括号。

注：

- 凡是可以使用 switch - case 的结构，都可以转换为 if - else。反之不成立。

- 写分支结构时，当发现既可以使用(case 的取值情况不能太多) switch-case, （同时，switch中表达式的取值情况不太多）， 又可以使用 if_else 优先使用 switch-case 

  原因： swicth - case  执行效率更高。

**想法：**

写程序的时候要先确定整体结构(模板)，然后思考有哪里不同。然后根据模板中无法确定的部分进行仔细调整。

##### 2. 循环结构

**循环结构的四要素**：

- 初始化语句
- 循环条件
- 循环体
- 迭代变量的改变

执行顺序：

① 初始化迭代变量

② 判断逻辑表达式, 

③ 如果结果为 true 则执行循环体，如果为 false 则跳出该循环、

④ 执行循环体后，增加或减少迭代变量的值。回到第二步

**for 循环:**

```
for（初始化迭代变量；逻辑表达式；循环之后的操作语句；）{
    循环体；
}
在 for 后面的圆括号里定义的变量称之为迭代变量。
```

注：for 循环中的迭代变量只有在 for 循环中有效，出了 for 循环就失效了。

**while 循环**:

```
初始化迭代变量
While（逻辑表达式）{
    循环体（重复执行的代码）;
    循环之后的操作语句；
}
//for 循环和 while 循环可以互相转换。
```

**do - while() 循环**：

```
初始化迭代变量
do{
    循环体;
    循环之后的操作语句
}while(逻辑表达式)
// do - while 至少执行一次循环体。
```

1. 不在循环条件部分限制次数的结构：for(;;) 或 while(true)
2. 结束循环的集中方式：
   - 方式一：循环条件部分返回 false;
   - 方式二： 在循环体中执行 break;

```
for(;;){}  === for(true){}
while(true){
    
}
```

##### 3. 嵌套循环

1. **嵌套循环**：将一个循环结构 A 声明在另一个循环结构 B 中。
2. 外层循环：循环结构 A 内层循环：循环结构 B
3. 内层循环执行了一遍，相当于外层循环执行了一次。
4. 假设外层循环需要执行 m 次，内层循环需要执行 n 次，此时内层循环的循环体一共执行了 m * n 次
5. 技巧：外层循环控制行数，内存循环控制列数。

##### 4. 控制循环结构语句

| break    | 终止当前循环, 执行该循环外的下一条语句 | switch - case、循环结构中                                    |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| continue | 终止当次循环                           | 循环结构中                                                   |
| return   | 终止当前方法                           | 终止后续循环，方法中以后的代码也不执行。 返回数据：return 数据//返回所需要的数据 |

**控制外层循环**：

给外层循环起名字。格式：

```
outter: for(){
    inside:for(){
        break outter;//结束指定标识符的循环
    }
}
```

##### 5. 从键盘获取不同类型的数据

**使用 Scanner 类：**

具体实现步骤：

1. 导包：import java.util.Scanner;

2. Scanner 的实例化。`Scanner sc = new Scanner(System.in);`

3. 调用 Scanner 类相关方法（next() / nextXxx()），来获取指定类型的变量。

   next() 获取字符串

4. 对于 char 类型的获取，Scanner 并没有提供相关的方法，只能获取一个字符串。

注意：
需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：`InputMisMatchException` 导致程序终止。

```
//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串
		System.out.println("请输入你的性别：(男/女)");
		String gender = scan.next();//"男"
		char genderChar = gender.charAt(0);//获取索引为0位置上的字符
		System.out.println(genderChar);
```

##### 6. 如何获取一个随机数：

方式一：`Math.random(); 取值范围 [0,1)`

公式：[a,b] : `(int)( Math.random * (b - a +1) ) + a; // a 和 b 是整数，求 a~b 之间的随机数。`

方式二：也可以通过 Random 对象来获取：

```
Random random = new Random();
random.nextInt(5);//范围 [0,5)
```

##### 7. 如何衡量代码的优略：

1. 正确性
2. 可读性
3. 健壮性
4. 高效率与低存储

### 第四章 数组

##### 1.数组

1.什么是数组？

把相同的数据类型数据有序排列的集合，并使用一个名字命名，并通过编号的方式，对这些数据进行同一管理。

2.数组的常见概念：

- 数组名
- 下标 (或索引\角标)：
- 元素: 数组中的每个数据
- 数组的长度：元素的个数

3.数组的特点：

1. 数组是有序排列的
2. 数组属于引用数据类型变量。数组的元素，既可以是引用数据类型 (或一个对象)，也可以是基本数据类型。
3. 创建数据就会在内存中开辟一整块连续的空间
4. 数组一旦确定长度就不能修改。、
5. 数组的分类：
   1. 按照维数：一维数组、二维数组……（多维数组）
   2. 按照数组元素的类型：基本数据类型元素的数组，引用数据类型的数组。

##### 2. 一维数组的使用

```
//一维数组的声明和初始化
类型名称[] 数组名称 = new 数据类型[]{数据}
//数组声明：
数组类型[] 数组名称
数组类型 数组名称[]
```

**数组初始化**：

静态初始化：在创建数组时，就已经确定了有多少个元素，并把元素放到数组之中。(数组的初始化和数组的赋值同时进行)

例如：`int[] ages = new int[]{12,23,23,24,34};`

动态初始化：在创建数组时，不知道要存放的数据值，所以先定义一个指定的空间大小。格式：`类型名称[] 数组名称=new 存放的数据类型[存放个数]；`

放入内容格式： `数组名称[角标] = 存放的数据；`

例如：

```
int[] ages = new int[10];
int[1] = 12;
……
```

扩展：

在 Java 中提供了一种创建数组对象并同时赋予初始值的简写模式

格式：`int[] smallPrimes = {1,2,3,4,5,5,55};`//注意不能换行

例如：

```
int[] smallPrimes;
smallPrimes = {1,2,3,4,5,5,55};//错误的
```

匿名数组：`new int[]{17,19,39,23,31,37}`

使用这种匿名数组可以再不创建新变量的情况下***重新初始化\***一个数组。例如：

```
int[] smallPrimes = new int[]{11,12,23,73,12,324,2343};
smallPrimes = new int[]{17,19,23,29,31,37};
```

\2. 如何获取数组指定为位置的元素：`数组名称[角标]；` 数组的角标是从 0 开始的

\3. 如何获取数组的长度：`数组名称.length`

\4. 如何遍历数组：

第一种:使用 for 循环(自己写)

第二种: 使用 for each 格式：`for(数组类型 变量名称: 数组){}` 

如果仅有一个数组，foreach 然后 `Alt + /` 

数组输出：`Arrays.toString(数组名称)；`

5.数组元素的默认初始化值：

> 整型： 0
>
> 浮点型：0.0
>
> char 型： 0 或 `\u0000`,而非 `0`
>
> boolean 型：false
>
> 引用数据类型：null

\6. 数组的内存解析：

注意：

1. 数组长度不要求是常量。例如：`new int[n]`
2. 可以使用`int[] a` 或 `int a[]`两种形式来声明数组

##### 3. 多维数组的使用

**二维数组**的使用

一维数组作为另一个一维数组的元素而存在(二维数组中的每个元素是一维数组)。因此，从数组底层的运行机制来看没有多维数组。

\1. 二维数组的声明和初始化：`数据类型[][] 数组名称 = new int[][]{多维数组的内容};`

静态初始化：`int[][] arr1 = new int[][]{{9，8，7},{2，3，4},{1，2，3}}`

动态初始化:

```
正确： 
String[][] arr2 = new String[3][2];
String[][] arr2 = new String[3][];//然后通过 arr2[index] 为第一曾
错误：
String[][] arr2 = new String[][2];
正确的声明格式：
数据类型[][] 数组名称
数据类型[] 数组名称[]
数据类型 数组名称[][]
```

**2. 多维数组元素的调用**：

```
int[][] allClassAges =new int[][]{{12,11,13,11,13,11,12},{12,11,12,12,12,11,13},{12,12,13,13,11,11,12}}
例子：获取 allClassAges 当中的第一个数组的第一个值。allClassAges[0][0];
```

获取元素内容 `数组名称\[数组序数\]\[数组中内容角标]；`

**3. 获取数组的长度**：

用嵌套 for 循环的方式来遍历二维数组

**遍历二维数组**

```
遍历上面的那个二维数组：
for(int i = 0;i <= allClassAges.length;i++){ // 遍历二维数组中的每一个元素
    int[] arr = allClassAges[i];
    for(int j = 0;j <= arr.length;j++){
        system.out.println(arr[i]);
    }
}
```

##### 4. 二维数组的默认初始化值

初始化方式一，例如：`int[][] arr = new int[4][3];`

- 外层元素：地址值 //因为我们在声明数组时，在初始化时就已经 new 了 n 个数。
- 内层元素：同一维数组默认值

初始化方式二，例如：`int[][] arr = new int[4][];`

- 外层元素： null
- 内层元素：无法调用。//没有声明 

##### 5. 数组中涉及常见的算法

1. 数组元素的赋值(杨辉三角、回形数等)

**杨辉三角**

```
int[][] arr = new int[10][];
for(int i = 0;i < arr.length;i++){
    arr[i] = new int[i + 1];
    arr[i][i] = arr[i][0] = 1;
    for(int j = 1;j < arr[i].length - 1;j++){
        arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];        
    }
}
//遍历输出
for (int[] numArr : arr) {
    for (int item : numArr) {
        System.out.printf("%d\t",item);
    }
    System.out.printf("\n");
}
```

**回形数：**

```
//第一种写法
        Scanner scanner = new Scanner(System.in);
        int len = scanner.nextInt();
        int[][] arr = new int[len][len];
        int count = 0;
        int minX = 0;
        int minY = 0;
        int maxX = len - 1;
        int maxY = len - 1;
        while (minX <= maxX) {
            for (int y = minY; y <= maxY; y++) {
                arr[minX][y] = ++count;
            }
            minX++;
            for (int x = minX; x <= maxX; x++) {
                arr[x][maxY] = ++count;
            }
            maxY--;
            for (int y = maxY; y >= minY; y--) {
                arr[maxX][y] = ++count;
            }
            maxX--;
            for (int x = maxX; x >= minX; x--) {
                arr[x][minY] = ++count;
            }
            minY++;
        }
//第二种写法
Scanner scanner = new Scanner(System.in);
        int len = scanner.nextInt();
        int[][] arr = new int[len][len];
        int x = 0;
        int y = 0;
        int sum = len * len;
        int k = 1;
        for(int count = 1; count <= sum; count++){
            if(k == 1){
                if(y < len && arr[x][y] == 0){
                    arr[x][y++] = count;
                }else{
                    k = 2;
                    x++;
                    y--;
                    count--;
                }
            }else if(k == 2){
                if(x < len && arr[x][y] == 0){
                    arr[x++][y] = count;
                }else{
                    k = 3;
                    x--;
                    y--;
                    count--;
                }
            }else if(k == 3){
                if(y >= 0 && arr[x][y] == 0){
                    arr[x][y--] = count;
                }else{
                    k = 4;
                    x--;
                    y++;
                    count--;
                }
            }else if(k == 4){
                if(x >= 0 && arr[x][y] == 0){
                    arr[x--][y] = count;
                }else{
                    k = 1;
                    x++;
                    y++;
                    count--;
                }
            }
        }
```

2.求数值型数组中元素的最大值、最小值、平均数、总和等。（过于简单不写了）

3.数组的复制、反转、查找（线性查找、二分法查找）

数组的复制：

```
int[] arr1,arr2;
arr1 = new int[]{123,2,32,323,34,4545,654,67,87}
第一种：
arr2 = new int[arr1.length];
for(int i = 0;i < arr2.length;i++){
    arr2[i] = arr1[i];
}
第二种：
arr2 = arr1.clone()；
//注意赋值和复制的区别。
int arr2 = arr1;
//这就是赋值，arr2 和 arr1 引用的是同一段地址空间。修改其中一个数组中的值，另一个数组中的值也会改变。
//上面的两种是复制。修改其中一个数组中的值，另一个数组的中的值不会改变。
```

数组的反转：

```
还是上面的那个数组
方式一：
for(int i = 0;i < arr1.length/2;i++{
	int temp = arr1[arr1.length - 1 - i];
	arr1[arr1.length - 1 - i] = arr[i];
	arr[i] = temp;
}
方式二：
for(int i  = 0, j = arr.length - 1; i < j; i++, j--){
	String temp = arr[i];
	arr[i] = arr[j];
	arr[j] = temp;
}
```

**查找**

线性查找

```
String[] dest =new String[]{"aa","bb","cc","dd","ee"};

boolena isFlag = true;
for(int i = 0;i < arr.length; i++){
    if(dest.equals(arr[i])){
    System.out.println("找到了指定的元素，位置为："+i)
    isFlag = flase;
    break
    }
}
if(isFlag){
    System.out.println("很遗憾，没有找到");
}

```

**二分法查找**

所查找的数组中的数据必须有序

```
int[] arr = new int[]{-23,23,34,46,58,97,100,123,135,147,156,178,189,195,200};
int dest = 34;//要找元素的值
int head = 0;//起始位
int end = arr.length - 1;//末位索引
boolean isFlag = true;
while(head <= end){
    int middle = (head + end) / 2;//中间位置的索引，如果是集合有偶数个，就取左边的那个值
    //从大到小排列
    if(arr[0] < arr[1]){
        if(dest == arr[middle]){
            System.out.println("找到了位置为" + middle);
            isFlag = false;
            break;//跳出循环
        }else if(dest > arr[middle]){
            begin = middle + 1;
        }else{
            end = middle - 1;
        }
    }
    //从小到大排列
    if(arr[0] > arr[1]){
        if(dest == arr[middle]){
            System.out.println("找到了位置为" + middle);
            isFlag = false;
            break;//跳出循环
        }else if(dest > arr[middle]){
            end = middle - 1;
        }else{
            begin = middle + 1;
        }
    }
}
```

如果一个数组分布较为均匀且有序，则可以使用 $\frac{值}{末项-首项}$

例如:偶数数组{2，4，6…100}

如果要判断 10 是否在这个数组中，则可以直接定位到这个数组的 $\frac{5}{49}$ 处附近进行查找。

数组元素的排序算法

##### 6. 排序

**什么是排序**？

假设有 n 个元素的序列 {$n_1,n_2…n_n$}，按照相应关键字的序列{$K1,K2,K3……Kn$}，将这个序列重新排序{$n_i1,n_i2,n_i3…n_in$}，使其相应的关键字满足从小到大，或从大到小，这样的一种操作叫做排序。

> 通常来说排序的目的就是为了快速查找

例如我们对商品进行排序，那么这个关键字可以是价格，销量，信誉，服务等进行排序。

**衡量排序算法优劣的指标**：

1. 时间复杂度：分析关键字的比较次数，和记录的移动次数。
2. 空间复杂度：肥西排序算法种需要多少辅助内存
3. 稳定性：若连个元素 A 和 B 的关键字值相等，但排序后 A，B 的先后次序保持不变，则称这种算法是稳定的。

> 追求高效率和低存储。

排序算法的分类：

- 内部排序:整个排序过程不要借助于外部存储器（磁盘等），所有排序操作都在内存中完成。
- 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程在内存中总完成，必须借助于外部存储器(如磁盘，以判),外部排序最常见的是多路并归排序，可以认为外部排序是多次内部排序组成。

**十大内部排序算法**

- 选择排序
  - 直接选择排序，*堆排序*
- 交换排序
  - **冒泡排序**，**快速排序** （要会手写）
- 插入排序
  - 直接插入排序，折半插入排序，Shell 排序。
- *归并排序*
- 桶式排序
- 基数排序

注：斜体，了解实现思想。

**算法的 5 大特征**

| 输入（Input）                    | 有 0 个或多个输入数据，这些输入必须有清楚的描述和定义        |
| -------------------------------- | ------------------------------------------------------------ |
| 输出（Output）                   | 至少有 1 个或个输出结果，不可以没有输出结果                  |
| 有穷性（有限性，Finiteness）     | 算法在有限的步骤之后，会自动结束而不会无限循环，并且每一个步骤都可以在可接受的时间内完成 |
| 确定性（明确性，Definiteness）   | 算法中的每一步都有明确的含义，不能含有歧义。                 |
| 可行性（有效性，Effecttiveness） | 算法的每一步都是清楚可行的，能让用户纸笔求出来答案。         |

注：满足确定性的算法称为：**确定性算法**。

现在人们考虑各种非确定性的算法，例如：**并行算法**，**概率算法**。

**冒泡排序**

主要通过两个关键字的比较，若与排序要求不符，则将两者交换。

**冒泡排序的基本思想**：通过对排序序列从前向后，依次比较相邻元素的关键字的值，若发现与要求不符，则交换两个元素。

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来，没有进行过交换，就说明序列有序，因此要在排序过程中设置一个 swap 判断是否进行过交换，如果没有进行过交换则说明这个序列式有序。

```
int[] arr = new int[] { 12, 123, 3243, -123, 1234, -9676, 134, 1234, 8795, 4567 };

        for (int i = 0; i < arr.length - 1; i++) {//需要比较多少轮
            //需要进行 n - 1 轮，arr.length - 1 是 n 轮，而 i < arr.length - 1 就是 n - 1
            for (int j = 0; j < arr.length - 1 - i; j++) {//需要比较多少次
                /**
                 * 加入有数组有 3 个元素。
                 * 共需要比较两轮。
                 * 第一轮需要比较 2 次。2-0 
                 * 而第二轮需要比较 1 次.(这一次也可以不进行),因为在 n - 2 次的最后一次比较中就已经将倒数第一个，倒数第二个进行比较了。修改：arr.length - 2
                 */
                if (arr[j] < arr[j + 1]) {
                    int temp = ar-r[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }

            }
        }

        System.out.println(Arrays.toString(arr));

```

**快速排序**

快速排序通常比同为 O(nlogn) 其他算法更快，因此常被采用，而且快排次啊用了分治法的思想。

式迄今所有算法中速度最快的一种。

**各种内部排序方法性能比较**

1. 从平均时间而言：快速排序最佳。但在最坏情况下可能不如归并排序和堆排序
2. 从算法简单性看：由于直接选择排序，直接插入排序和冒泡排序的算法比较简单，将其认为是*简单排序*。对于 shell 排序，堆排序，可快速排序和归并排序，算法比较复杂，认识是*复杂排序*。
3. 从稳定性看：直接插入排序，冒泡排序和归并排序是稳定的，而直接选择排序，快速排序，shell 排序和堆排序是不稳定排序。

**排序算法的选择**

1. 若 n (要排序元素的个数)比较小如( n ≤ 50)可采用直接插入排序或直接选择排序。

   当规模较小时，直接插入排序较好；否则因为直接选择移动的元素少于直接插入，应该直接选择排序为宜。

2. 若文件初始状态基本有序，则应选用直接插入，冒泡或随机的快速排序为宜。

3. 若 n 较大，则采用时间负责为 O(nlgn) 的排序方法：快速排序，归并排序，堆排序。

##### 7. Arrays 工具类的使用：

Arrays 是操作数组的工具类，常用的有以下这些。

| boolean equals()    | 判断连个数组是否相等         |                                  |
| ------------------- | ---------------------------- | -------------------------------- |
| String toStrng()    | 输出数组信息                 |                                  |
| void fill()         | 将指定数值替换到数组之中     |                                  |
| void sort()         | 对数组进行排序               |                                  |
| int binarySearch(); | 对排序后的数组进行二分法查找 | 找到了返回角标，找不到返回一个负 |

##### 8. 数组使用过程中常见异常。

`ArrayIndexOutOfBoundsExcetion` 数组角标越界（角标的值，不在约定的范围之内 0 ~ arr.length  - 1）

`NullPointerException`:	空指针异常

情况一：

```
int[] arr = new int[]{1,2,3,4};
arr1 = null;
```

情况二：

```
int[][] arr = new int[4][];
System.out.println(arr[0][0]);
```

情况三：

```
String[] arr = new String[]{"AA","BB","CC"};
arr[0] = null;
System.out.println(arr[0]);
```

#  Java 面向对象

[TOC]

### 第一章 面向对象上

学习面向对象的三条主线：

1. Java 类及类的成员：属性，方法，构造器；代码块，内部类；
2. 面向对象的三大特征：封装、继承、多态、(抽象性)
3. 关键字: this,super,static,final,abstract,interface 等 

##### 1. 面向过程 (POP)与面向对象 ( OOP)

- 面向过程和面向对象都是一种思想。面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调了具备功能的对象，以类/对象为最小单位，考虑谁来做。
- 面向对象更加强调人类在日常的思维逻辑中采用的思想方法原则，如抽象、分类、继承、聚合、多态等。

**面向对象的思想概述**

- 程序员从面向过程的执行者转化成了面向对象的指挥者。
- 面向对象分析方法 分析问题的思路和步骤：
  - 根据问题需要，选择问题所针对的现实世界中的实体。
  - 从现实世界中寻找解决问题的相关的属性和功能，这些属性和功能就形成了概念（世界）中的类。
  - 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即用某种计算机语言，把类构造成计算机能够识别和处理的数据结构
  - 将类实例化形成计算机世界中的对象，对象是计算机世界中解决问题的最终工具

面向过程：Procedure Oriented Programming 

面向对象：Object Oriented Programming

##### 2. Java 基本元素类和对象

**类**：把具有相同"属性"和"行为"的多个对象抽象化就是类；是对一类事物的描述，是抽象的、概念上的定义。例如：人类、动物类、植物类 …

**对象**：对象是实际存在的该类事物的实体（个体），因而也称实例（instance）。包含属性(成员变量)，行为 (或功能 )的一个实体，对象也称为实例。

理解：假设人是一个对象。那么它的肤色，升高、发色等是成员变量，而行为则是所作出的行动，比如聊天、玩手机等。

- 由类构造对象的过程，我们称之为“**构建类的实例** ” 或 “**类的实例化**”。

- 面向对象程序设计的重点是类的设计。

- 类的设计，其实就是类的成员的设计。

- 两者之间的关系：类是创造对象的模板，而对象是的类实例化。

- 对象的属性用(成员)变量表示。对象的行为用方法表示。

  Field == 属性 == 成员变量 == 域、字段。Method == （成员）方法  == 函数

类定义的格式：

```java
class Person{
                //描述属性(特征)；
                String name;
                int height;
                double weight;
                //描述行为
                void sing(){

                }
                void eat(){

                }
}
```

**对象的创建**

- 格式：` 类 对象名 = new 类名();`
- 对对象中的属性赋值：`对象名.变量名 = 值；`
- 调用对象的属性：`对象名.属性名`
- 对象调用方法：`对象名.方法名（ 参数）`。

类和对象的使用步骤：

1. 创建类，设计类的成员
2. 类的实例化
3. 通过 `对象.属性` 或 `对象.方法` 调用对象的结构。

如果创建了一个类的多个对象，则每个类独立的拥有一套属性 (非 static)。意味着：如果我们修改一个对象属性 A 的值，则其它对象的属性 A 的值不受影响。

**JVM 内存解析**

JVM 将运行数据区主要划分为：方法区（Method Area 静态区）、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、堆(Heap)、程序计数器(Program Couter Register)。

- **堆 (heap)**：存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例以及数组都要在堆上分配。（每使用一次 new 关键字，就表示在堆中开辟一块新的的存储空间。）
- **栈  (VM stack)**:我们通常所说的栈是虚拟机栈。主要用于存放 局部变量等。局部变量表存放了编译器可知长度的各种基本数据类型 (boolean、byte、char、short、int、float、long、double),对象引用(reference 类型，它不等同于对象本身，存放的是对象在对内存(堆中)的首地址)。方法执行完自动释放。
  - 执行每一个调用的函数（方法），就为这个函数创建一个栈帧(里面存放的都是该方法的成员变量，也就是 局部变量)，并加入虚拟机栈。函数执行完毕后出栈。
- **方法区 (Method Area):** 用于存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的字节码等数据。
  - 常量池
  - 静态域
- **程序计数器**：每个线程都有个计数器记录当前执行到那行代码。

##### 3. 类的成员之二：方法

- 面向对象的角度来说：方法是对象的功能/行为的体现 (实现)。
- 从一般角度而言，方法就把一段代码存放起来可以重复使用。

方法：描述类具有的功能。

比如：Math 类、sqrt()\random()\…

​				Scanner 类，nextxxx()\…

​				Arrays 类， sort()\binarysearch()\toSting()\…

方法的完整形式：

```java
[权限修饰符] 返回值类型 方法名([形参列表]){
     方法体;
}
注：Void  表示什么都不返回。
例子：
	static int sum(int a,int b){
        int res  =  a  +  b;
         return res;
	}
如果要返回一个值，格式 return 返回值；
```

注：除了用权限修饰符来修饰 方法，还可以使用 static、abstract、final 来修饰方法。

说明：

1. 返回值类型：
   1. 如果方法有返回值，必须在声明方法时，指定返回值的类型。同时方法必须用 return 关键字来返回指定类型的变量或常量。 
   2. 如果方法没有返回值，则方法声明时，使用 void 来修饰。通常，不使用 return 语句,如果要使用的话，只能是 "`return;`"  表示结束该方法。
2. 形参列表：方法可以声明 n 个形参，（n &in; N^*^）。如果声明多个形参，形参之间用英文逗号隔开。

**return 关键字的使用：**

1. 使用范围：使用在方法体中。
2. 作用：
   1. 结束方法；
   2. 针对有返回值的方法，使用 `return 数据`返回指定类型的数据。
3. 注意：return 关键字后不可以有执行语句。

**注意点**：

1. 方法要定义在其他方法之外（跟其它方法平级）。注意：`mian()` 也是方法
2. 定义方法不分先后顺序。
3. 如果一个方法中有 static，那么在该方法中调用的其他方法前也该有 `static`
4. 方法声明在 class 当中，一个类当中可以有多个方法。
5. 方法的使用中可以调用当前对象的属性或方法。

**万事万物皆对象：**

1. 在 Java 语言中，我们将属性、行为等封装到类中，通过类的实例化，来实现具体的功能。
2. 当 Java 与前端、后端的数据库进行交互式，都体体现为类、对象。

**匿名对象**：

1. 我们创建的对象，没有显式的赋给一个变量名。 （没有名称的对象）。
2. 格式：`new Dog().name.方法名称`
3. 特征：因为没有名称，匿名对象仅仅只能使用一次，一般的把匿名对象作为方法的实参传承。
4. 使用如下(也就是说将匿名对象作为方法实参传入时可以多次使用)：

```java
public class PhoneTest{
    public static void main（String[] args）{
        PhoneMail mail = new PhoneMail();
        mail.show(new Phone());
    }
}
class Phone{
    double Price = 1999.0;//价格
    //功能
    public void sendEmail(){
        System.out.println("发邮件");
    }
    public void playGame(){
        System.out.println("玩游戏");
    }
    public void show price(){
        System.out.println("价格为" + price);    
    }
    
}
class PhoneMail{
    
    public void show(Phone phone){
        phone.show();
        phone.playGmae();
        phone.sendEmail();
    }
}
```

##### 5. 再谈方法

方法必须由其所在类或所在类的对象调用

形参：方法声明时的参数。即小括号中声明的内容。

实参：方法调用时实际传给方法形参的参数值。

**方法重载**：

在同一个类中，允许存在同名方法，但只要参数列表不同 (参数个数，参数类型不同)。

- 两同：在同一个类中，方法名相同
- 一不同：参数列表不同

调用重载方法时，根据方法参数列表的不同来选择所执行的方法。

举例：Arrays 类中的 sort() / binarySearch()

**可变个数的形参**：

JavaSE 5.0 中新增： Variable number of arguments

- 在定义方法时，形参(等同于)是一个数组。
- 格式: `数据类型 … 变量名`
- 用三个点代表可变参数：是数组参数的一种简写(在它的内部会自动把 “...” 转换为数组)；
- 具体使用：
  - 当调用可变个数形参的方法时，参入的参数个数可以是，0 个，1 个， ……
  - 可变个数形参的方法与同类中方法名相同，形参类型也相同的数组不构成重载。
  - 可变个数新参在方法的形参中，必须声明在末尾
  - 可变个数形参在方法的形参中，只能声明一个可变形参。

```java
static void sum(int...args){//== static void sum(int[] args){
	int res = 0;
	for(int i = 0;i < args.length;i++){
		res += args[i]; 
	}
	System.out.println(res);
}
调用可变参数，也能传进去一个数组：
sum(1,2,3,4);
而数组参数只能传进去一个数组：
sum(int[] ages = new int[]{1,2,3,4});
```

注：可变个数形参在方法的形参中，必须声明在末尾。

理解：假如有多个行参，如果第一个或中间就是可变个数形参，那么 JVM 将会不知道如何划分。

**方法形参的值传递机制:**

- 方法必须由其所在类或类的对象调用。
  - 形参：方法声明时的参数
  - 实参：方法调用时，实际传给形参的参数值

***Java* 中的实参值时如何传入方法呢？**

在 Java 中参数的传递方式只有一种：值传递。即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。

值传递，即将**实际参数值的副本传入方法内**，而参数本身不受影响。（因此如果交换两个数值，只能用引用数据类型。）

- 如果参数是基本数据类型：传递的是数据值
- 如果参数是引用数据类型：传递的是地址值（包含了数据的类型：包名.数据类型@hashcode）。
- 一个数据只能赋值给同类型的变量量。

例题：

```java
class TransferTest{

    public void first(){
        int i = 5;
        Value v = new Value();
        v.i = 25;
        second(v,i);
        System.out.println(v.i);//15
    }

    public void second(Value v,int i){
        i = 0;
        v.i =20;
        Value val = new Value();
        v = val;//到这里地址值就和外面的不一样了
        System.out.println(v.i+""+ i);//15 0
    }
}

class Value{
    int i = 15;
}
```

总结：

1. 如果传递的基本数据类型，那么在方法内进行改变，并不会改变方法外实参的值。
2. 如果传递的是引用数据类型，如果在方法内改变，那么在方法外也要随之改变。如果重新对引用数据类型的值进行赋值，那么方法外的引用数据类型也不会改变（例如上面的代码）。

面试题：

```java
Public static void main(String[] args){
      	int a1 = 10;
        int b1 = 10;
        test.method(a1,b1);
        System.out.println("a=" + a1);
        System.out.println("b=" + b1);
    //在调用 method() 方法之后，仅打印出 a=100,b=200,请写出method 方法的代码
}
方式一：
终止虚拟机
public void method(int a,int b){
        System.out.println("a="+100);
        System.out.println("b="+200);
        System.exit(0);//将虚拟机终止
}
方式二：
重写打印流
public static mehtod(int a,int b){
    PrintStream ps = new PrintStream(System.out){
            @Override
            public void println(String x) {
//                super.println(x);
                if("a=10".equals(x)){
                    x="a=100";
                }else if("b=10".equals(x)){
                    x="b=200";
                }
                super.println(x);
            }
        };

        System.setOut(ps);
}
```

```java
int arr = new int[10];
System.out.println(arr);//地址值
char[] arr1 = new int[]{'a','b','c'};
System.out.println(arr1);//abc 内部会将 char[] 类型的数据进行遍历，然后打印
```

**递归**：

在一个方法体中调用它自身， 我们将其称为 **递归**。

- 方法递归包含了一种隐式的循环，它会重复执行代码，但这种代码无序循环控制。
- 递归一定要向已知方向递归，负责这种递归就会变成无穷递归(死循环)。

例如求斐波那契数列：

```java
public int getFeiBona(int n ){
    if(n == 1 || n == 2){//当 n 为第一个或 第二个时返回 1.
    	return 1;
    }else{
        return getFeiBona(n-1) + getFeiBona(n-2);
    }
}
```

##### 6. OOP 封装与隐藏

封装就是将实现细节隐藏起来，然后对外公开接口，便于外界调用， 从而提高系统的可扩展性和可维护性。

**程序设计追求“高内聚，低耦合”**。

高内聚：类的内部数据操作操作细节，不允许外部干涉。

低耦合：仅对外暴露少量的方法用于使用。

例如：厨师做菜，每个人都可以到饭店让厨师给你做饭。我们并不需要关心这些饭菜是如何做出来的。

**问题的引入**：

当我们创建一个对象以后，可以通过 “对象.属性” 的方式，对对象的属性进行赋值。这里的赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他的限制条件。但是在实际问题中我们需要给属性添加额外的限制条件。这个条件就就不能在属性体现，我们只能通过方法进行限制条件的添加。(同时我们需要避免用户通过 “对象.属性” 方式，对属性进行赋值，则需要将属性声明为私有的 priveate)——>此时就体现对象的封装性。

**封装性的体现**：

体现一：我们即将类的属性私有化 (private)，同时，提供公共的方法 (public) 来获取和设置属性的值 (get 和  set )。

体现二：不对外暴露的私有的方法。

体现三：封装性的体现需要权限修饰符的配合。

体现四：单例模式(将构造器私有化)

体现五：如果不希望类在包外被使用，可以将类设置为缺省的。

权限修饰符可以修饰类的内部结构：属性，方法，构造器，内部类。

​		修饰类 (外部类) 只能使用缺省和 public。

**封装性总结**：Java 提供四种权限修饰符来封装类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。

##### 7. 类的成员之三：构造器 Constructor

```
constrct 建设；建造
construction 
constructor 建设者
```

构造器：在创建对象时自动调用的方法，称为**构造器**。

1. 构造器的作用：创建对象，初始化对象的信息。
2. 如果显式的定义构造器，则默认提供一个空参的构造器。
3. 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器。
4. 一个类中至少有一个构造器
5. 定义构造器的格式：权限修饰符 类名(形参){方法体}
6. 可以定义多个构造器，彼此之间形成重载。

**说明**：

1. 构造器名称和当前类名一样。
2. 禁止有返回值类型。void 是返回值为空，因此不能使用 void 用作返回值（构造器其实是返回值，它返回的是当前创建对象的地址\[在堆中\]）
3. 一个类中至少有一个构造器。
4. 默认的构造器的权限修饰符是 public（同类一致）

**默认构造器和自定义构造器的不同点：**默认构造器没有有形参，而自定义构造器有形参

例子：

```java
public class User{
    String name = "myxq";//会在默认会在构造器中设置
    public User(){
        // 默认构造器：不可见(但通过反编译工具可以看到)
    }
    public static void main(String[] args){
        User user1 = new User();//这里的User() 就是构造器
    }
}
```

属性赋值的先后顺序：

1. 默认初始化
2. 显式初始化
3. 构造器中赋值
4. 通过 "对象.方法" 或 “对象.属性赋值”

**JavaBean:**

JavaBean 是一种 Java 语言的可重用组件。

*JavaBean 指符合以下标准的 Java 类*：

- 类是公共的。
- 有一个无参的公共的构造器
- 有属性且有对应的 get,set 方法。

**介绍 UML 类图**：

1. +表示 public 类型，- 表示 private 类型，# 表示 protected
2. 方法的写法：方法的类型（+ -）方法名（参数名：参数类型）：返回类型

<img src="C:/Users/XJ/Documents/MarkdownImages/UMLContructor.png">

##### 8. 关键字：this

1. this 可以用来修饰属性、构造器、方法。
   - 在方法内部使用，表示调用这个方法的对象。
   - 在构造器内部使用，表示构造器正在初始化的对象。

在类的方法中，我们可以使用 “this.属性”或“this.方法”的方式，调用当前对象的属性或方法。通常情况下，我们选择省略 “this.”。特殊情况下，也就是当方法的形参和类的属性重名时，我们必须用 “this.属性”的方式，表明此变量是属性，而非形参。

```java
public class Person{
    private String name;
    private int age;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }   
}
```

**this 调用构造器：**

- 在类的构造器中，可以显式的使用 “`this(形参列表)`”，调用本类中的*其他*构造器。
- 如果一个类中有 n 个构造器，则最多有 n - 1 个构造器中使用了 “`this(形参列表)；`”
- 规定“`this(形参列表);`”必须声明在当前构造器的首行
- 构造器内部，最多只能声明一个“`this(形参列表)；`”来调用其他的构造器。

```java
public Class Person{
    private String name;
    private int age;
    public Person(){
        //在创建对象时需要考虑的几个条件限制
        System.out.println("在创建对象时需要考虑的几个限制条件");
    }
    public Person(String name){
		this()；
        this.name = name;
    }
    public Person(int age){
        this();
        this.age = age;
    }
    public Person(String name,int age){
        this(age);
        this.name = name 
    }
}

```

##### 9. 关键字：import,package

**package 关键字的使用：**

问题引入：

在开发中我们存在几百个上千个 java 文件，如果所有的 java 文件都在一个目录中，管理起来很麻烦。

1. 为了更好的实现项目中包的管理提供了包的概念。(java 也可以创建类似文件夹的东西，我们称这个文件夹为 包。)
2. 使用 package 声明类或接口所在的包，声明在圆文件的首行
3. 每 “.” 一次，代表一层文件目录。
4. 同一个包下，不可命名同名的结构。
5. 格式：package 包名.包名.子包  //使用 package 声明类或接口所属的包
6. 包名定义：公司域名倒写 使用格式：Package 域名倒写.模块名.组件名

作用：

1. 将相似或相关的类或接口组织在同一个包中，方便类的查找和使用(为了更方便管理)。
2. 包规定了访问权限，拥有访问权限的类才能访问某个包中的类。

**类的名称**：

- 类的简单名称： 直接类名
- 类的全限名称：包名.类名

在开发中先有包名再有类名。

**Java 中主要的包**

- java.lang——(lanauage)包含 Java 的一些核心类，如：String,Math,Integer,System 和 Thread，提供常用功能。
- java.net——包含执行与网络相关的操作的类和接口
- java.io——包含能提供多种输入/输出功能的类
- java.util——包含一些实用工具类，如定义系统特性，
- java.text——包含 Java 格式化相关的类
- java.sql—— 包含 Java 进行JDBC 数据库编程的相关类和接口。
- java.awt——包含了构成抽象窗口的工具集(abstract,window,lookits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI).

**MVC 设计模式**

MVC 将程序分为三个层次: 识图模型，控制器层，数据模型层

- 模型层 model 主要处理数据
  - 数据对象封装	model.bean/domain
  - 数据库操作类   model.dao
  - 数据库     model.db
- 视图层 view 显示数据 //数据的展示
  - 相关工具类：view.utils
  - 自定义view:    view.ui
- 控制层 controller 处理业务逻辑//程序输入输出
  - 应用界面线管 controller.activity
  - 存放 fragment controller.fragment
  - 存放列表的适配器 controoler.adapter
  - 服务相关的 contoller.service
  - 抽取的基类： controller.base

这种将程序输入输出，数据处理以及数据的展示分离开来的设计模式使程序结构变的灵活且清晰，同时也描述了程序各个对象的通信方式，降低程序的耦合性。

<img src="C:/Users/XJ/Documents/MarkdownImages/MVC.png"> 

**Import 关键字的使用：**

问题引入：当 A 类和 B 类不在一个包中，若 A 类需要使用到 B 类 (或 B 类中的结构)，此时就让 A 类中引入 B 类。

1. 在源文件中显式的使用 import 导入指定包下的类或接口。格式：improt 包名.类名/接口名；

2. 声明 在包的声明和类的声明之间。如果需要导入多个包并列写出即可。

3. 可以使用 `import xxxx.*` 的方式，表示导入 xxxx 包下的所有结构。即：可以使用 “包名.类名”，也可以使用 “包名” ,表示导入包下所有的结构。如果需要调用该包下子包的结构，仍然需要调用显示导入。

4. 如果使用的类或接口是 Java.lang 下定义的，则可以省略 import 导入语句。

   如过使用的类或结构式本包下定义的，则也可以省略 import 导入语句。

5. 如果在源文件中，使用了不同包下的同名文件，则至少有一个类需要以全类名的方式显式。(这里的全类名指的是：包名.类名/接口名.类中方法或对象) 

6. import static: 导入指定类或接口下的静态结构(方法或属性)。

例如：`import static java.lang.Math.*;`

方法：1. ctrl+shift+o  

2.将鼠标指针放到错误处，然后点击 import 语句

系统提前帮我们做了很多功能，他们放到了包里面，我们只需要把他们从制定的包里导入，就可以使用了。

使用系统提供的功能，需要从系统的包里导入类。

静态导入（了解）【不推荐使用，因为有部分功能不能使用】：

把其他包里面的内容在本类中使用，不需要使用类名调用，直接使用别的包里的方法。

Important static 类的权限定名，该类中中的static成员名：在实际开发中，我们不使用静态导入，因为如此分不清某一个静态方法或字段源于哪一个类。

### 第二章 面向对象中

##### 1. OOP 特征二：继承性 inheritance

> extends 延展，扩展

一、继承性的好处：

1. 减少了代码的冗余，提高了代码的复用性
2. 便于功能的扩展
3. 为之后多态性的使用提供了前提

二、继承的格式：`class A extends B{}`

​	A: 子类、派生类、subclass

​	B: 父类、超类、基类、<u>superclass</u>

体现：一旦子类 A 继承 B 以后，子类 A 中就获取了父类 B 中的结构 (属性、方法)。

特别的：

1. 特别的：父类中声明为 private 的属性和方法，子类继承父类以后，仍然认为获得了父类私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。
2. 子类继承父类之后，还可以声明自己特有的属性和方法。实现功能的拓展。

三、 Java 中关于继承的规定

Java 只支持单继承和多层继承，不允许多重继承 (也就是说一个类只允许有一个直接父类)。

- 单继承：一个子类只能有一个直接父类。
- 多重继承：一个子类可以有多个直接父类。
- 一个父类可以派生出多个子类。
- 多层继承：A 继承 B ，B 又继承C。
- 子类直接继承的父类，称为：“直接父类”；子类间接继承的父类称为 “间接父类”
- 子类继承父类以后，就获取了直接父类及所有间接父类中的结构。

四、

1. 如果我们没有显式的声明一个类的父类，则此类继承于 java.lang.Object 
2. 所有的 Java 类都直接或间接继承 Java.lang.Object 类(除它本身) (在 Java 中：Object 类，所有类的根父类。)
3. 意味着，所有 Java 类具有 Object 中声明的功能。

##### 2. 方法的重写 (override / overwrite)

一、重写定义：

在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在执行程序时，子类对象调用该方法时，子类的方法将覆盖父类的方法。

二、应用： 当重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数方法，执行的是在子类中被重写的方法。

三、要求；

1. 子类重写的方法和父类被重写的方法具有相同的方法名称，参数列表。

2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类类型。

3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。也就是 $子类权限 \geq 父类权限$。

   - 子类不能重写父类中声明为 private 权限的方法。

4. 子类方法抛出的异常不大于父类被重写方法抛出的异常。

5. 返回值类型：

   - 父类被重写的方法返回值类型是 void ，则子类重写的方法的返回值类型也只能是 void.

   - 子类被重写的方法的返回值是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类

   - 父类被重写的方法是基本数据类型(比如 int 类型)，则子类重写的的方法的返回值类型必须相同。

注意：

1. 子类与父类中同名、同参数的方法要么都声明为非 static (可以考虑重写),要么都声明为 static 的(不是重写)。
2. 格式：`@override  重写的方法`

##### 3. 四种访问权限修饰符

1.什么是访问权限修饰符？

访问权限修饰符用来限定该类成员的访问权限。

- **Private** 表示私有的，便是类访问权限，*只能在本类中访问*，离开本类就不能直接访问
- **Protected** 表示子类访问权限，*同包中的可以访问*，不同包中不能访问，继承也可以访问。
- **Public**  表示全局的，公共访问权限，使用了public 修饰符，则可以在当前项目中任何地方访问。
- 默认 表示包访问权限，访问者的包必须和当前定义类的包相同才能访问，继承不能访问

| 作用域       | 当前类   | 同一包中 | 子孙类   | 其他包(仅限于当前项目) |
| ------------ | -------- | -------- | -------- | ---------------------- |
| public       | 可以访问 | 可以访问 | 可以访问 | 可以访问               |
| protected    | 可以访问 | 可以访问 | 可以访问 | 不能访问               |
| private      | 可以访问 | 不能访问 | 不能访问 | 不能访问               |
| 默认（缺省） | 可以访问 | 可以访问 | 不能访问 | 不能访问               |

##### 4. 关键字 super

1. super: 理解为 父类的。

2. super 可以调用 属性，方法，构造器。

3. super 的使用：

   a. 一般情况，我们可以在子类的方法或构造器中，通过使用 “`super.`” 的方式显式的调用父类中声明的属性和方法。但是通常情况下，我们习惯省略 “`super.`”

   b. 特殊情况，当我们对父类的方法进行重写或子类中的属性与父类中的属性重名时，我们想要带哦用父类就方法或属性就要使用 "`super.`" 的方式，表明调用的是父类中的属性或方法。

   c. 当子类重写父类的方法以后，我们想在子类的方法中调用父类中被重写的方法时，必须使用 `super.方法` 的方式，白哦名调用的时父类中被重写的方法。

注：

1. 当我们在子类中没有显式的用 "`super.`",那么我们调用的都是 “`this.`”（只不过我们进行了省略）。
2. 当我们子类与父类中的方法或属性不重名时，程序在执行时会先查看子类当中是否有该方法或属性，如果没有该方法或属性就到父类当中寻找，直到找到为止。如果在子类中找到了，就不继续向上寻找了。

##### super 调用构造器

- `this(形参列表)` 表示调用当前类中指定的构造器(由形参列表决定)。
- `super(形参列表)` 表示调用父类当中指定的构造器(由形参列表决定)
- `this(形参列表) 和 super(形参列表)` 的使用，必须声明在子类构造器的首行。
- 在类构造器中 `this(形参列表)` 和 `super(形参列表)` 只能二选一，并且只能存在一个调用的构造器。
- 在构造器的首行没有显式的调用构造器(包括 this(形参列表)  或 super(形参列表))，则默认调用父类当中的空参构造器(也就是 super())。
- 在类的多个构造器中，至少有一个类的构造器中使用了 "`super(形参列表)`" 构造器。

##### 5. 子类对象实例化过程

- 从结果上来看：

子类继承父类以后，就获取父类中声明的属性和方法。创建的子类对象，在堆空间中，就会加载所有父类中声明的结构。

- 从过程上来看：

当我们通过子类的构造器老创建对象时，我们一定会直接会间接的调用父类的构造器，进而调用父类的父类构造器，……，直到调用了 java.lang.Object 类中空参的构造器为止。正因为加载了所有父类的结构，所以，在内存中才可以看到父类中的结构，子类对象才可以考虑进行调用。

注意：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建了一个对象，即 new 的子类对象。

##### 6. OOP 特征三：多态性

1. 可以理解为：一个事物的多种形态。

2. 父类的引用可以指向子类的对象，在运行时仍然保持子类的特征。（也就说：可以将子类的对象赋值给父类数据类型）

   创建子类对象首先要初始父类。因为子类继承了父类当中所有的属性和方法，因此一类有必要知道如何父类如何对对象进行初始化。

3. **多态的使用**：

   有了对象多态性以后，在编译时，我们只能调用父类当中声明的方法，但在运行时，执行的时子类重写父类的方法。(没有重写的仍然调用父类当中的方法)

   注：编译看左边，运行看右边。

4. 多态性使用的前提：

   - 类的继承关系
   - 方法的重写。

对象的多态性只适用于方法，不适用于属性。

虚拟方法调用(Virtual Method Invocation)

多态情况下：

子类中定义了父类中同名同参数的方法。在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同的子类对象，动态的调用子类的方法。这样的方法调用在*编译期时*无法确定的。

**编译时类型和运行类型**：

```java
Person p = new Student();
e.getInfo()
```

编译时 p 为父类类型（p 为 Person 类型），而方法的调用实在运行时确定的，调用的子类的方法。

例子：

```java
class Animal{
    public void eat(){
        System.out.println("Animal eat food");
    }
    public static Animal getInstance(int key){
        switch(key){
            case 0:
                return new Cat();
            case 1:
                return new Dog();
            deault:
                return new Sheep();
         }
    }
    public static void main(String[] str){
    int key = new Random().nextInt(3);     	 
    Animal animal = getInstance(key);
    animal.eat();
    }
}
class Cat extends Animal{
    public void eat(){
        System.out.println("cate eat fish");
    }
}
class Dog extends Animal{
	public  void eat(){
        System.out.println("dog eat bo e");
    }    
}
class Sheep extends Animal{
    public void eat(){
        System.out.println("Sheep eat grass");
    }
}
```

重载是在同一个类中，允许多个同名的方法，二这些方法的参数列表。编译器根据方法不同的参数列表，对同名方法的名称进行修饰(绑定)。对于编译器而言，这些同名的不同的方法，它们要调用的具体的方法(地址)，在编译时就绑定了。Java 的重载是可以包括父类和子类，即子类可以可以继承父类同名不同参数的方法。

对于重载而言，在方法调用之前，编译器就一定所要调用的方法，这称为 "早绑定" 或 "静态绑定"。

对于多带，只有等到方法调用时，解释运行才确定具体要调用的具体的方法。这称为 "晚绑定" 或 “动态绑定”。

**nstanceof 操作符**

有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中中声明的属性和方法。子类特有的属性和方法不能调用。

**如何才能使用子类特有的属性和方法**？

向下转型，使用强制类型转换符。

```java
Person p1 = new Student();
Student stu = (Student)p1;//这样以后就可以用子类特有的方法和属性了。
```

使用强转时，可能出现 ClassCastException 异常。

 格式：`a instanceof A` //判断对象 a 是否是 类 A 的实例。如果是返回 true,如果不是返回 false

使用场景：为了避免向下转型时出现异常。我们在向下转型之前，先进行 instanceof 的判断。

##### 7. Objct 的使用：

1. 所有 Java 类的根父类
2. 如果类的声明中未使用 extends 关键字指明父类，则默认父类为 java.lang.Object 类
3. Object 类中的功能具有通用性。
4. Object 类只声明了一个空参构造器。

程序员可以通过 System.gc() 或 getRuntime().gc 通知系统进行垃圾回收，。

垃圾回收机制在回收任何对象之前，都会先调用 finalize 方法 。

在垃圾回收之前调用 finallize();

equals 比较两个对象是否相等。

##### == 和 equals 的区别

== 运算符

1. 可以使用在比较基本数据类型变量和引用数据类型变量中。
2. 如果比较的时基本数据类型，比较两个变量报数的数据值。<br/>
   如果比较的时引用数据类型，比较两个对象的地址值是否相同。

注：== 要保证两边的变量类一致。

equals 方法的使用

1. 是一个方法，而非运算符
2. 只能使用与引用数据类型。
3. Object类中equals的定义：   

```
pulic boolean equals(Object obj){
    return this == obj;
}
```

Object 类中定义的 equals 和 == 的作用时相同的。

1. 像 String、Date、File、包装类等都重写了 equals 的方法。（比较两个对象的“实体内容”是否相同）

2. 我们自定义的类使用 equals,通常是想比较两个对象的"实体内容"是否相同，如何对其进行重写。

//重写写的原则比较两个对象的实体内容。

自定义类重写 equals

```java
@Override
public boolean equals(Object obj){
    if(this == obj)
        return true;//是否是同一个对象
    if(obj instanceof Customer){
        Customer cust = (Customer)obj;
        //比较两个对象的属性是否相等
        return this.age == cust.age && this.name.equals(cust.name);
        }else{
            return false
        }
}

```

**toString  的使用**：

1. 当我们输出一个对象的时候，实际上就是调用 toString();
2. Object 类中 toString 的定义：

```java
public String toString(){
    return getClass().getName() + "@" + Interger.toHexString(hashCode());
}
```

3. 像 String、Date、File、包装类都重写了 Object 类中的 toString();
4. 对自定义类进行重写 toString 方法，当该类的对象，调用此方法时可以输出对象的实体内容。

```java
String str;

System.out.print(str);//null
System.out.println(str.toString());//NullPointerException

//因为在 print 中定义；
public void println(String x){
	synchronized(this){
		print(x);
		newLine();
	}
}
public void print(String s){
    if(s = null){
        s = null;
    }
    write(s);
}
```

##### 8. 包装类的使用：

- 针对八种基本数据类型定义相应的引用类型 —— 包装类。

- 有了类的特点，就可以调用类中的方法。

| byte    | Byte      |
| ------- | --------- |
| int     | Integer   |
| long    | Long      |
| short   | Short     |
| float   | Float     |
| double  | Double    |
| boolean | Boolean   |
| char    | Character |

Java 提供了八种基本数据类型的包装类，使得基本数据类型具有类的特征。

**基本数据类型，包装类和 String 之间的相互转换**

注意：转换时，可能会出线 NumberFormatException （当 String 转换为包装类或基本数据类型时可能出现的异常）

```java
Integer in3 = new Intger("abc123");//NumberFormatEException
System.out.println(in3.toString());
```

**基本数据类型转换为包装类**：

- JDK 9 之前：可以调用包装类的构造：`数据类型 变量名 = new 数据类型(该类型的值或包裹该类型的字符串)`; 

  注意：boolean 类型的字符串不区分大小写。

- JDK 9 之后：对以前的调用包装类的构造器进行废除。新格式：赋值格式等同于基本数据类型。

**包装类转换为基本数据类型**：

调用包装类的.xxxValue();这里的 xxx 为包装类对应的基本数据类型。

```java
Integer in1 = new Integer(12);
int i1 = in1.intValue();

```

**自动装箱和自动拆箱**：

JDK 5.0 以后有了自动装箱和拆箱。包装类和基本数据类型自动行进转换。

**基本数据类、包装类转换为 String**：

方式一：用 "" 做连接运算

```java
int num = 10;
String str1 = num1 + "";

```

方式二：调用 String 的 valueOf(x);

```
float f1 = 12.3f;
String str2 = String.valueOf(f1);

```

**String 类型转换为 基本数据类型、包装类**：调用parsexxx();

例子：

```java
String num = `12321`;
int num2 = Integer.parseInt(str1);

```

### 第三章 面向对象下

##### 1. Static 修饰符

当我们声明一个类时，其实就是描述对象的属性和行为，但是并没有产生对象，只有当我们使用关键字 new 时才会产生对象，这时系统才分配内存空间给对象。其方法才可以被外部调用。

有时，我们希望无论是否产生了对象或产生了多少对象，某些特定的数据在内存空间中只有一份（是属于类的）。

注：属性和行为应该有类和对象之分。

Static （静态的）关键字的使用：

1. static 用来修饰类的结构 ：属性、方法、代码块、内部类。

2. 使用 static 修饰属性:我们称之为**静态属性(类变量)**。

   属性按是否使用 static 修饰，又分为：静态属性 和 非静态属性。

   - 实例变量（非静态属性）：我们创建了多个对象，每个对象都独立的拥有一套非静态属性。当我们修改了一个对象的非静态属性时，不会导致其他对象中同样属性，值的修改。
     静态属性：我们创建了多个对象，多个对象就共享同一个静态属性。当通过对象修改静态属性时，就会导致其他对象的静态属性的修改。

   - 静态属性的说明：

     - 静态变量随着的类的加载而加载

     - 静态变量的加载要早于对象的创建。

     - 由于类只会加载一次，则静态变量在内存中也只会存在一份。存储在方法区的静态域中.

     - |      | 类变量 | 实例变量 |
       | ---- | ------ | -------- |
       | 类   | yes    | no       |
       | 对象 | yes    | yes      |

       即：类只可以调用类变量，而对象既可以调用类变量也可以调用实例变量(依据生命周期)。

3. 静态属性的举例： System.out;Math.PI;

使用 static 修饰的方法：静态方法

1. 随着类的加载而加载，可以通过 "类.方法" 的形式进行调用

2. 静态方法中只能调用静态方法或属性，非静态方法，即可以调用静态方法和属性，也可以调用非静态的方法和属性。

   //由于 static 方法是随着类的加载而加载的，而非静态的方法在这个时候是没有加载的，因此，就不能调用非静态的方法。

3. static 注意点：

   1. 在静态方法内，不能使用 this,super 关键字

      //this 指的是当前对象的，而 super 指的是当前对象父类的(y而是基于当前对象的)，而 static 是属于类的，生命周期在于对象，在那时对象不一定存在，因此不能有 this 和 super 关键字。

   2. 从声明周期的角度理解静态属性和方法的使用。(晚 "出生" 可以调用早 “出生” 的，早 “出生” 的不可以调用晚 “出生” 的)

4. 在开发中如何确定一个方法或属性是否要用 static 修饰？

   - 属性是否可以被多个对象所共享，不会随着对象的不同而不同
   - 操作静态属性的方法，
   - 工具类中的方法，习惯上声明为 static。举例：Math,Arrays,Collections

**类变量和实例变量：**

 如果在字段和方法之前加了 static，那么这个字段和方法就属于类。(可以通过 类名.结构 调用)

作用：确定修饰的内容是属于类还是属于对象。

特点：

1. Static 修饰的内容，是随着类的加载而加载。当JVM 把字节码加载到虚拟机当中，static 修饰的成员会自动的加载到内存当中。（方法区）
2. Static 修饰的内容，优先于现实的对象。
3. Static 修饰的内容，被该类的所有对像所共享。

成员变量中的成员;字段、方法、内部类。

- 类成员：使用 static 修饰的成员，
- 实例成员：没有使用 static 修饰的成员。

类成员和实例成员的访问：

1. 在 static 方法（静态方法）中只能调用static成员（静态成员。）。
2. 非 static 方法可以访问静态成员也可以访问非静态成员。

什么时候使用static？

被所有对象共享时。

##### 2. 单例设计模式与理解 main 的语法

设计模式是在大量实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。

单例设计模式，就是采取一定方法保证在整个软件系统中，某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

第一步：首先将类的构造器的访问泉下设置为 private

//这样就不能在类的外部用 new 来创建类的对象了。

第二步：在类的内部产生该类的对象。

第三步：在类的外部无法创建类的对象，只能调用该类的某个静态方法以返回类的内部创建对象，静态的方法，只能访问类中的静态成员变量，所以指向类内部产生的该类对象的变量也必须定义成静态的。

详见 设计模式.md

##### 3. 代码块

1. 代码块的作用：用来初始化、对象

2. 代码块如果有修饰的话，只能用 static 修饰

3. 分类：静态代码块 、非静态代码块

4. 静态代码块：

   - 随着类的加载而执行，且只执行一次//相对于非静态代码块来说先执行
   - 作用：初始化类的信息
   - 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
   - 静态代码块*只*能调用静态的成员变量或方法

   非静态代码块：

   - 随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块。
   - 可以在创建对象时，对对象的属性进行初始化。
   - 如果一个类定义了多个非静态代码块，也是按照声明的先后顺序执行。
   - 可以调用静态的成员变量和方法，和非静态的成员变量和方法。
   - 非静态代码块优先于构造器先执行。

属性赋值的先后顺序：

1. 默认初始化
2. 显式初始化 / 代码块中赋值(按照在代码块中的先后顺序)
3. 构造器中赋值
4. 通过 "对象.属性" 或 "对象.方法" 赋值

##### 4. 关键字：final 

final 表示最终的

1. final 可以用来修饰类、方法和变量。

2. 修饰类：不可以被继承。 例如：Strting,System,StringBuffer

   //该有的都有了。就算继承了的也玩不出什么新花样。

3. 修饰方法：不可以被重写。

4. 修饰变量：

   此时的 "变量" 我们将其称之为常量。只能被赋值一次。

   - **修饰属性**，可以考虑赋值的位置有：显式初始化、代码块中赋值、构造器中赋值

     注：如果需要在构造器中赋值，则需要在每个构造器中对其进行赋值。

     > 如果构造器没有调用那个给常量赋值赋值，且没有在构造器中赋值，那么就等同于该常量仅仅是定义，并没有对该属性赋值，这是不允许的。
     >
     > 为什么不可以在方法中对 final 修饰的属性进行赋值?
     >
     > 1. 因为构造器是创建的对象的最后一步，一旦出了构造器这个对象就创建完成了。而属性在这时都已经有值了。由于该属性是常量只可以赋值一次，因此就不可再赋值了。
     > 2. 方法不一定被调用。
     >
     > 注：常量不可以使用默认初始化。
     >
     > 选择：
     >
     > 1. 如果多个对象的 "属性" 具有相同的值，那么就显式的初始化
     > 2. 如果需要调用方法对其进行赋值，还有可能有异常，还要处理异常那么就再代码块中进行赋值
     > 3. 如果多个对象的 “属性” 值不同，那么就在构造器中进行赋值 。

   - **修饰局部变量**：

     使用 final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给该形参赋值，赋值之后，只能在方法中使用此形参，但不能对其进行重新赋值(修改)。

static final 修饰属性：全局(类)常量。修饰方法：

面试题：编译和运行是否有错误

```java
public class Something(){
    public static void main(String[] args){
        Other o = new Other();
        new Something().addOne(o);
    }
    public void addOne(final Other o){
        //o = new Other();
        o.i++;
    }
}
  class Other(){
        public int i;
    }
```

答没有错误，因为 final 修饰的是形参 o,当我们调用此方法方法时，就会给常量形参赋值，但是在 addOne() 方法中只可以使用但是不可以对其进行修改或重新赋值。如果 `o = new Other();` 没有注释那就就会报错，因为它对 o 进行了重新赋值。但是 `o.i++` 是对 o 的属性进行修改，但 final 并没有对 `o.i` 进行修饰。例如：一个人从出生都是这个人，但是它的属性可能会发生改变例如年龄，身高颜值等

> 对象在底层是一个地址值，只要我们不对这个地址值进行修改。那么就不会报错，如果我们对其进行重新赋值，那么就会报错。

##### 5. 抽象类与抽象方法

随着一个个子类的定义，类变得越来越具体，而父类则更一般，更通用，类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。\

```java
/*
 * abstract关键字的使用
 * 1.abstract：抽象的
 * 2.abstract 可以用来修饰的结构：类、方法
 * 
 * 3. abstract 修饰类：抽象类
 * 		> 此类不能实例化
 *      > 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
 *      > 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作
 * 
 * 
 * 4. abstract 修饰方法：抽象方法
 * 		> 抽象方法只有方法的声明，没有方法体
 * 		> 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
 *      > 若子类重写了父类中的所有的抽象方法后，此子类方可实例化
 *        若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰
 */
public class AbstractTest {
	public static void main(String[] args) {
		
		//一旦Person类抽象了，就不可实例化
//		Person p1 = new Person();
//		p1.eat();
		
	}
}

abstract class Creature{
	public abstract void breath();
}

abstract class Person extends Creature{
	String name;
	int age;
	
	public Person(){
		
	}
	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}
	
	//不是抽象方法：
//	public void eat(){
//		
//	}
	//抽象方法
	public abstract void eat();
	
	public void walk(){
		System.out.println("人走路");
	}
	
	
}


class Student extends Person{
	
	public Student(String name,int age){
		super(name,age);
	}
	public Student(){
	}
	
	public void eat(){
		System.out.println("学生多吃有营养的食物");
	}

	@Override
	public void breath() {
		System.out.println("学生应该呼吸新鲜的没有雾霾的空气");
	}
}
```

注：**包含抽象方法的类一定是抽象类。抽象类中不一定有抽象方法(也就是说一个方法一旦被 abastract 修饰，那么这个这个方法必须被重写)。**

注：抽象方法不能被该类所创建的对象调用。

abstract 使用过程中注意点：

1. abstract不能用来修饰：属性、构造器等结构

2. abstract 不能用来修饰私有方法、静态方法、final  的方法和类。

超类声明一个方法可以不实现（也就是没有方法体），该方法的实现哟子类提供实现，而这样的方法我们称之为 “抽象方法”。有一个或更多抽象方法的类称为 “抽象类”。

***匿名类***

创建抽象类的匿名对象：

例子

```java
public class PersonTest{
    public static void main(String[] args){
        Person per = new Person(){
            @Overide
            public abstract walk(){
            }
            @Override
            public abstract eat(){
                
            }//这就是一个匿名类
        };
    }
}

public abstract class Person{
    public abstract void walk();
    public abstract void eat();
}
```

##### 6. 接口 interface

- 有时必须从几个类中派生出一子类，继承它们所有的结构。但是 Java 不支持多重继承。有了接口，就可以得到多重继承。
- 有时必须从几个类中抽取一些共同的行为特征，而它们之间没有 is - a 的关系，仅仅是具有相同的行为特征而已。例如：USB，type - c 接口 

接口的本质是**契约、标准、规范**。（都要遵守）

```java
/*
 * 接口的使用
 * 1.接口使用 interface 来定义
 * 2.Java中，接口和类是并列的两个结构
 * 3.如何定义接口：定义接口中的成员
 * 		
 * 		3.1 JDK7及以前：只能定义全局常量和抽象方法
 * 			>全局常量：public static final的.但是书写时，可以省略不写
 * 			>抽象方法：public abstract的
 * 			
 * 		3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）
 *		- 静态方法： 用 public static  修饰的方法。
 * 
 * 4. 接口中不能定义构造器的！意味着接口不可以实例化
 * 
 * 5. Java开发中，接口通过让类去实现(implements)的方式来使用.
 *    如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化
 *    如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
 *    
 * 6. Java类可以实现多个接口   --->弥补了Java单继承性的局限性
 *   格式：class AA extends BB implements CC,DD,EE
 *   
 * 7. 接口与接口之间可以继承，而且可以多继承
 * 
 * *******************************
 * 8. 接口的具体使用，体现多态性
 * 9. 接口，实际上可以看做是一种规范
 * 
 * 面试题：抽象类与接口有哪些异同？
 * 
 */
public class InterfaceTest {
	public static void main(String[] args) {
		System.out.println(Flyable.MAX_SPEED);
		System.out.println(Flyable.MIN_SPEED);
//		Flyable.MIN_SPEED = 2;
		
		Plane plane = new Plane();
		plane.fly();
	}
}


interface Flyable{
	
	//全局常量
	public static final int MAX_SPEED = 7900;//第一宇宙速度
	int MIN_SPEED = 1;//省略了public static final
	
	//抽象方法
	public abstract void fly();
	//省略了public abstract
	void stop();
	
	
	//Interfaces cannot have constructors
//	public Flyable(){
//		
//	}
}
```

注：JDK 1.8 中的结构：

使用：通过接口直接调用静态方法（接口的实现类中没有访问权限）。

- 默认方法：用 default 修饰的方法

  使用：通过实现类的对象，调用接口中的默认方法。

  - 如果实现类重写接口中默认的方法，那么调用的就是重写以后的方法。

  - 如果子类（实现类）继承的父类和接口中声明有同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用父类中父类中的同名同参数的方法（类优先原则）。

  - 如果实现类中实现了多个接口，而接口中定义了多个同名同参数的 方法。实现类在没有重写此方法的情况下，报错。——> 接口冲突
    这就需要在实现类中重写此方法。

    ```java
    如何在子类或现类中调用被重写的方法。
    方法名();//用来调用自己重写的方法
    super.方法名();//用来调用父类中的方法
    接口名.super.方法名();//用来定义接口中的默认方法
    ```

    public 可以省略不写  

10. 开发中，体会面向接口编程。

```java
以下方法的接口为 USB
1.创建接口的非匿名实现类的非匿名对象。
Computer com = new Computer();  
//这里 Computer 是接口的非匿名实现类
2. 创建非匿名是实现类的匿名对象。
com.transferData(new Printer());
// 这里的 transferData 为匿名类中的抽象方法
3. 创建接口的匿名实现类对象
USB u = new USB(){
	//抽象方法的实现。
};
4. 创建接口的匿名实现类的匿名对象。
 com.transferData(new USB(){
 //抽象方法的实现
 });

```

**比较两个对象的大小：**

根据对象的属性值来比较大小。

```java
public int compareTo(Object o){
    //返回 0 代表相等，返回为正数，则表示当前的对象大，返回为负数则表示，传入的对象大
    if(this == o){
        return 0;
    }
    if(o instanceof 该类的名称){
        //声明属性为基本数据类型
        进行强转，然后进行判断。
        //声明属性为包装类
       return 当前对象的属性.compareTo(传入对象的属性)；
    }else{
        抛出异常
    }
}
```

接口的应用：

静态代理(一种设计模式)：

代理设计就是为其它对象提供一种代理以控制对这个对象的访问。

应用场景：

- 安全代理：屏蔽对真实角色的直接访问
- 远程代理：通过代理类实现远程方法调用。
- 延迟加载：先加载轻量级的加载的对象，等到有需要再打开

代理的分类：

- 静态代理：静态定义代理类
- 动态代理：动态定义代理类
  - JDK 自带的动态代理，需要反射等知识

##### 7. 内部类

- 在 Java 中允许一个类的定义位于另一个类的内部。前者称为**内部类**。后者称为**外部类**。
  内部类只为外部类提供服务。

- 内部类的分类：

  - 局部内部类：方法内、代码块内、构造器内
  - 成员内部类：静态、非静态

- 成员内部类：

  1. 作为外部类的成员：
     1. 调用外部类的结构。
     2. 可以被 static 修饰
     3. 可以被 4 种不同的权限修饰
  2. 作为一个类：
     1. 内部可以属性、方法、构造器等内部结构。
     2. 可以被 final, abstract 修饰

  调用外部类的属性或方法(非静态的)，那么前面要用 `类名.this.` 来修饰，可以省略。

需要关注的问题：

- 如何实例化成员内部类的对象？

  ```java
  外部类为 Person, 内部类为 Bird
  // 如果内部类为静态：
  Person.Bird b = new Person.Bird();
  //如果内部类为非静态
  Person per = new Person();
  Person.Bird = per.new Bird();
  ```

- 如何在成员内部类种区分调用外部类的结构？

  ```java
  //假设在内部类、外部类和形参种都定义了同名属性(或方法)
  public void printName(String name){
      name;//为形参
      this.name;//内部类中结构
      perosn.this.name;//外部类中的结构。
  }
  ```

- 在开发种局部内部类如何使用？

方法的返回值是实现了某个接口的对象。

成员内部类和外部类编译后字节码文件格式：

> 成员内部类:`外部类名$内部类名.class`
>
> 局部内部类：外部类$数字 内部类名。class

在局部内部类的方法中，如果调用局部内部类所声明的方法中的局部变量时，要求此局部变量声明为 final

```java
public void method(){
	int num = 10;//此局部变量必须声明为final
	class AA{
	
	public void show(){
		//在这里调用 num 
	}
	}
}
```

在 JDK 7 及以前版本，要求此变量显式的声明为 final

JDK 8 及以后的版本，final 可以省略不写

### 第四章 异常处理

##### 1.异常概述和异常体系结构

问题引入：再使用计算机语言进行项目开发的过程中，我们尽可能把代码写得尽善尽美，在系统的运行过程仍然会遇到一些问题，很多问题并不是靠代码就能够避免的。比如：**客户输入数据的格式、读取文件是否存在，网络是否始终保持畅通**。

异常：在 Java 语言中，将程序**执行**中发生的不正常情况称为 "异常"。（开发过程中的语法和逻辑错误不是异常）

Java 程序在执行过程中所发生的异常事件可分为两类：

- **Error**: JVM 无法解决的严重问题。如：JVM 系统 内部错误、资源耗尽等内部情况 。比如：StackOverflowError(栈溢出) 和 OOM(堆溢出)，一般不编写针对性的代码进行处理。
- **Exception**:其他因编程错误或偶然的外在因素导致一般性问题，可以使用针对性的代码进行处理。
  - 空指针访问
  - 试图读取不存在的文件
  - 网络中断连接
  - 数组角标越界

注：在这章中我们所说的异常就是 Exception

**异常的分类：**

Java.lang.Throwable

> Java.lang.Error:一般不编写针对性的代码进行处理。
>
> Java.lang.Exception:可以进行异常处理。
>
> > 编译时异常(checked)
> >
> > > IOException
> > >
> > > > FileNotFoundException
> > >
> > > ClassNotFoundException
> > >
> > > ……
> >
> > 运行时异常(unchecked)
> >
> > > NullPointerException
> > >
> > > ArrayIndexOutOfBounds
> > >
> > > ClassCastException
> > >
> > > NumberFormatException
> > >
> > > InputMismatchException
> > >
> > > ArithmeticException

Exception 又可以分为：

- 受检异常 == 编译时异常 
- 非受检异常 == 运行时异常

对于这些错误的解决方法。

一、遇到错误就终止程序的运行。

二、有程序员在程序编写时，就考虑到错误的检测、错误消息的提示、以及 错误的处理。

##### 2.常见异常

**运行时异常**：

NullPointerException 空指针异常：

```java
int[] arr = null;
System.out.println(arr[1]);
```

ArrayIndexOutOfBoundsException 数组角标越界：

```java
int arr = new int[3];
System.out.println(arr[3]);
```

ClassCastException 类型转换异常：

```java
Object obj = new Man();
Woman test = (Object)obj;
```

NumberFormatException:

```
String str = "abc";
int num = Interger.parseInt(Str);
```

InputismatchException:输入不匹配

```java
Scanner scan = new Scanner(System.in);
int score = scanner.nextInt();
System.oubiant.println(score);
```

ArithmeicException 运算异常：

```java
int num = 10;
int num1 = 0;
System.out.println(num / mum1);
```

**编译时异常**

##### 3.异常处理机制一：try-catch-finally

在编写程序时，要在可能出现错误的地方加上检测的代码。而过多的检测语句 (if-else 等)，会导致程序的代码加长、臃肿、可读性差。因此采用异常处理。

**Java 异常处理:**

Java 采用的异常处理机制，是将异常处理的程序代码集中在一起与正常的艾玛分开，使程序简洁、优雅易于维护。

**Java  异常处理的方式：**

方式一：try - catch  - finally

方式二： throws + 异常类型。

抓抛模型：

过程一：'**抛**'，程序在正常执行的过程中，一旦出现异常，就会在异常代码除生成一个异常类对象，然后将对象抛出。

一旦抛出对象以后，对象以后的代码就不会执行了。

过程二：’**抓**‘，可以理解为异常的处理方式：1. try - catch - finally 	2. throws 

***Try - catch - finaly** 的处理：

```java
try{
    //可能出现按异常的代码
}catch (异常类型 1 变量名){
   //异常的处理方式 1
}catch (变量类型 2 变量名){
    //异常的处理方式 2
}catch (变量类型 3 变量名){
   //异常处理的方式 3 
}……
finally{
    //一定会执行的代码
}
```

说明：

1. finally 使可选的

2. 使用 try 将可能出现的异常包装起来，在执行过程中，一旦出现出现异常就会生成一个异常类的对象，根据对象的类型，去 catch 中进行匹配(匹配的是 catch 的形参类型

3. 一旦 try 中的异常对象匹配到某一个 catch 时，就进入 catch 中进行异常的处理。一旦处理完成就会跳出当前的 try-catch 结构（在没有写 finally 情况）。继续执行其后的代码。

4. catch 中的异常类型如果没有字符类关系，则谁声明在上，谁声明在下无所谓。

   catch 中声明的异常类型如果满足子类关系，则要求子类一定要声明在父类上面，否则，报错。

5. 异常的处理方式：

   1. String getMessage();//这里的 String 是返回值类型。为什么报错
   2. printStrackTrace()；//在哪儿报错

6. 使用 try - catch - finally 结构式嵌套的。 

用 try - catch - finally 来处理编译时异常，在编译时不报错，但在运行时会报错，相当于我们把编译时可能出现的异常，延迟到运行时。

开发，由于运行式异常比较常见，所以我们通常不针对运行时异常写 try - catch - finally ,针对编译时异常，我们一定要考虑异常处理。

**finally 的使用**

说明：

1. finally 是可选的。
2. finally 代码块中的代码时一定会被执行的,即使 catch 中又出现了异常，try/catch 中又 return 语句等情况(finally 中的内容会先于 catch/try 中的 return 语句执行。)。
3. 像数据库连接、输入输出流、网络编程 Scoket 等资源，JVM 是不能自动回收的，我们需要自行进行资源的释放。此时资源的释放，就要声明在 finally 当中。

**编译时异常，和运行异常的不同处理**

##### 4.异常处理机制二：throws

`throws +  异常类型` 写在方法声明处，指明此方法执行时，可能会抛出的异常类型。一旦当方法执行时，出现异常，仍会在异常代码除生成一个异常类的对象，此对象满足 throws 后异常类型就会被抛出。异常代码后续的代码，就无法执行了。

2. 体会：try - catch - finally :真正的将异常处理掉了。

​		throws 的方式只是将异常抛给方法的调用者，并没有真正的将异常处理调。

3. 开发中如何选择 try -catch - finally，还是 throws?

   3.1 如果父类中重写没有 throws 抛出异常，则子类重写的方法的也不能使用 throws。意味着子类重写的方法中有异常，必须使用 `try - catch - finally`处理异常

   3.2 执行的 A 方法中，先后调用两外几个方法，这几个方法是递进关系执行的（这里的递进关系是指前一个方法处理的结果，作为参数传进后一个方法）。建议：调用的那几个方法用 throws 的方式进行处理，二执行的方法在 A 中使用 try - catch - finally 的方式进行处理。

注意:

方法的重写的规则：

1. 子类重写的方法抛出的异常不大于父类被重写的方法抛出异常。

##### 5.手动抛出异常：throw

关于异常对象的产生：

1. 系统自动生成的异常对象。
2. 手动的生成生成异常对象，并抛出 throw.

语法标记：`thorw new 异常类型();`

##### 6.用户自定义异常类     

注意：在方法中不能以 static 修饰变量

成员变量有初始值：不初始化，会有默认值，可以直接使用。

- **局部变量**:定义在方法当中的变量（参数和内部定义的变量，代码块）

局部变量初始值;必须要初始值，只有初始化之后才能使用。初始化才会在内存中开辟空间。

变量的作用域变量根据定义的位置的不同，也觉得各自的作用域是不同的，看变量所在的{}；

成员变量在整个类中都有效。     

局部变量：只在它定义的大括号内生效。

变量的作用域是指：变量的存在的范围，只有在这个范围内，程序代码才能访问它。当一个变量被定义时，它的作用域就确定了。

变量的生命周期：一个变量被创建并分配内存空间开始到该变量被销毁并清除所占内存空间的过程。

| 存放位置                              | 声明周期开始         | 生命周期结束             | 内存位置 |
| ------------------------------------- | -------------------- | ------------------------ | -------- |
| 类变量          使用 static           | 所在字节码加载到 JVM | 该类被回首时             | 方法区   |
| 实例变量      没有 static             | 创建类所在的对象     | 对象被回收时             | 堆       |
| 局部变量   方法参数，方法内，代码块内 | 执行初始化变量       | 所在的方法或代码块执行结 |          |

[TOC]

